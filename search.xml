<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>操作系统基础</title>
      <link href="2021/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h2><p>1.pwd #(now place)<br>2.cd .. #返回上一级<br>3.cd + path #to path<br>4.cd - #previous path<br>5.ls+path #查看某文件夹下的内容<br>6.ls -l #more info<br>7.ls -lR #everydircontent and info<br>8.mkdir #make file<br>9.touch #建立文档<br>10.rm #del<br>11.echo helloworld &gt; new.txt #write content into txt (cover)<br>12.echo abc &gt;&gt; new.txt #(add to)<br>13.cp 2.txt /path/3.txt #(复制文档)<br>14.cp -r /file /newpath/ (复制文件)<br>15.mv 2.txt /path/2.txt（move）<br>16.cat #全部打印<br>17.more #翻页查看<br>18.head -n 3 abc.txt#看前三行<br>19.ctrl U #清理光标前内容<br>20.ctrl K #清理光标后内容<br>21.tar cvf 2.tar 1.txt #压缩<br>22.tar xvf 2.tar#解压缩<br>23.which java #find where is java</p><h2 id="VIM命令"><a href="#VIM命令" class="headerlink" title="VIM命令"></a>VIM命令</h2><p>1./hello #search<br>2.esc+: 2 #to second<br>3.dd #删除光标所在行<br>4.ndd #删除光标下n行<br>5.yy #copy一行<br>6.set nu #显示行号<br>7.p $paste</p><h2 id="Linux用户权限划分命令"><a href="#Linux用户权限划分命令" class="headerlink" title="Linux用户权限划分命令"></a>Linux用户权限划分命令</h2><p>用户组：特征相同的用户集合<br>一个用户可同时在多组</p><p>1.useradd #add user<br>2.usermod -g usergroup username #fix usergroup<br>3.usermode -l newname username #fix name<br>4.userdel username#del user<br>5.passwd username #set pwd to user,if null,is set root</p><h2 id="文件权限命令"><a href="#文件权限命令" class="headerlink" title="文件权限命令"></a>文件权限命令</h2><p>文件权限先判断是否所有者，否，再判断在不在有权限的组，全为否则属于其他用户<br>无权限-0，777最高权限，644普通文件权限，755执行权限<br>u(user),g(group),o(other),a(all)<br>rwx=421<br>-表示文档,d表示文件</p><p>1.chomd +x #添加执行权限 chmod -x#去除执行权限<br>2.chmod u(now user)/o(other user) + x #给当前/其他用户执行权限</p><h2 id="目录权限命令"><a href="#目录权限命令" class="headerlink" title="目录权限命令"></a>目录权限命令</h2><p>拥有x（执行权限）则代表可以cd进入</p><p>1.chown user:usergroup 1.txt #修改文件所有者,组<br>2.chown -R user:usergroup filename #递归修改目录里面的文档权限，改了文件的权限，并不会修改文件里文档的权限</p><h1 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h1><h2 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h2><p>虚拟文件系统VFS(Virtual File System):能够衔接各种各样的文件系统，因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。</p><p><img src="https://pic3.zhimg.com/80/v2-212ca855ac2dad87983b23b6539e21ce_1440w.jpg" alt="Linux文件系统结构"></p><p>​                                                                                                       </p><img src="https://pic3.zhimg.com/v2-b92499b17ed11bc279689ecdb6efb4b6_b.jpg" alt="Linux文件系统结构" style="zoom: 67%;"><p>​                                                                                                          </p><p>​                                              <img src="https://pic2.zhimg.com/v2-9d77e25913894df26b0374ceae25c605_b.jpg" alt="索引节点、目录项以及文件数据关系图"></p><p>​                                                                                               <em>索引节点、目录项以及文件数据关系图</em></p><p><strong>索引节点（ <em>inode</em>）</strong>用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。</p><p><strong>目录项（<em>dentry</em>）</strong>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>，目录则存在于磁盘。</p><p><img src="https://pic2.zhimg.com/v2-d9e36f97b24b2a7f760a81d0b095c36d_b.jpg" alt="块分布图"></p><p>引导块：在系统启动时用于启用引导<br><strong>超级块</strong>:包含的是文件系统的重要信息，比如 inode信息，块信息<br><strong>块组描述符</strong>:包含文件系统中<strong>各个块组</strong>的状态，比如块组中空闲块和 inode 的数目等<br>数据位图和 inode 位图：用于表示对应的数据块或 inode 状态<br>inode 列表:包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据<br>数据块:包含文件的有用数据</p><p>ext2（索引式文件系统）<br>ext3（日志式文件系统）<br>ext4（日志式文件系统）</p><h2 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h2><ol><li><p>普通文件（-）</p><ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li></ol></li><li><p>目录文件（d，directory file）</p></li><li><p>符号链接（l，symbolic link）</p><ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li><p>块设备文件（b，block）和字符设备文件（c，char）</p><ol><li><p>这些文件一般隐藏在/dev目录下，在进行设备读取和外设交互时会被使用到</p></li><li><p>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</p></li><li><p>系统中的所有设备要么是块设备文件，要么是字符设备文件</p></li><li><p>FIFO（p，pipe）</p></li><li><p>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</p><p>6.套接字（s，socket）</p></li><li><p>用于进程间的网络通信，也可以用于本机之间的非网络通信</p></li></ol></li></ol><h2 id="Linux文件目录"><a href="#Linux文件目录" class="headerlink" title="Linux文件目录"></a>Linux文件目录</h2><img src="https://pic3.zhimg.com/80/v2-b90ccc05d3a17b7bf30e4528faf96f4a_1440w.jpg" alt="Linux文件目录" style="zoom:33%;"><h1 id="Linux的引导和启动"><a href="#Linux的引导和启动" class="headerlink" title="Linux的引导和启动"></a>Linux的引导和启动</h1><p>事实上，操作系统的启动分为两个阶段：引导和启动。<br>引导阶段开始于打开电源开关或者重启，结束于内核初始化完成和 systemd 进程成功运行。<br>启动阶段接管了剩余工作，直到操作系统进入可操作状态。</p><ul><li>BIOS 上电自检（POST）</li><li>引导装载程序 (GRUB2)</li><li>内核初始化</li><li>启动 systemd，其是所有进程之父</li></ul><h2 id="引导过程"><a href="#引导过程" class="headerlink" title="引导过程"></a>引导过程</h2><h3 id="BIOS-上电自检（POST）"><a href="#BIOS-上电自检（POST）" class="headerlink" title="BIOS 上电自检（POST）"></a>BIOS 上电自检（POST）</h3><p>上电自检主要由硬件的部分来完成。<br>BIOS 上电自检确认硬件的功能正常后查找引导扇区，随后有效引导记录的第一个引导扇区被装载到内存中，并且控制权也转移到此段代码。</p><h3 id="引导装载程序-GRUB2"><a href="#引导装载程序-GRUB2" class="headerlink" title="引导装载程序 (GRUB2)"></a>引导装载程序 (GRUB2)</h3><p>GRUB2 是一个用于计算机寻找内核并加载其到内存的程序。</p><p>1.BIOS 将查找MBR（主引导记录）<br>2.加载 Linux 内核到内存，转移控制权到内核<br>3.内核(压缩格式)自解压完成，则加载 <a href="https://en.wikipedia.org/wiki/Systemd">systemd</a> 进程并转移控制权到<br>4.这就是引导过程的结束。此刻，Linux 内核和 systemd 处于运行状态</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><h3 id="启动systemd"><a href="#启动systemd" class="headerlink" title="启动systemd"></a>启动systemd</h3><p>1.systemd 是所有进程的父进程。<br>2.用户级目标态（<code>multi-user.target</code> 或 <code>graphical.target</code>） 初始化</p><h3 id="启动完成标准"><a href="#启动完成标准" class="headerlink" title="启动完成标准"></a>启动完成标准</h3><p>以 <code>*</code> 开头的目标态是通用的启动状态,说明系统已经启动完成。eg: *graphical.target or *multi-user.target</p><h1 id="Windows基础"><a href="#Windows基础" class="headerlink" title="Windows基础"></a>Windows基础</h1><h2 id="Windows引导和启动"><a href="#Windows引导和启动" class="headerlink" title="Windows引导和启动"></a>Windows引导和启动</h2><p>目前主要的系统引导方式也有两种：<br>1.传统BIOS + MBR<br>2.新型UEFI + GPT<br>UEFI BIOS可同时识别MBR分区和GPT分区，所以MBR和GPT磁盘都可用于启动操作系统，但是UEFI下只能将系统安装在GPT磁盘中。<br>UEFI是一个微型操作系统，能够识别FAT文件系统，运行efi程序。</p><h3 id="传统BIOS-MBR"><a href="#传统BIOS-MBR" class="headerlink" title="传统BIOS + MBR"></a>传统BIOS + MBR</h3><p><img src="https://pic2.zhimg.com/80/v2-151011877000bb57b29c0c86576a5691_1440w.jpg" alt="传统BIOS + MBR"></p><p>1.上电，执行Legacy BIOS.<br>2.进行POST自检，完成硬件初始化。<br>3.查找MBR中的IPL（用于确定活动主分区），找到该分区的引导扇区（第一个扇区）中的引导记录（PBR），载入PBR中的启动管理器（bootmgr.exe或NTLDR）。<br>4.bootmgr.exe读取该分区根目录下boot文件夹里的启动设置文件（BCD或boot.ini），然后载入程序winload.exe（位置：C:\Windows\system32\winload.exe）来加载OS内核。<br>5.内核程序执行系统初始化。</p><h3 id="新型UEFI-GPT"><a href="#新型UEFI-GPT" class="headerlink" title="新型UEFI + GPT"></a>新型UEFI + GPT</h3><p><img src="https://pic2.zhimg.com/80/v2-c6d908835871f938fe71c783b4cc8e01_1440w.jpg" alt="新型UEFI + GPT"></p><p>1.开机，执行UEFI BIOS。<br>2.UEFI BIOS运行预加载环境先直接初始化CPU和内存，CPU和内存若有问题则直接黑屏，其后启动PXE采用枚举方式搜索各种硬件并加载驱动，完成硬件初始化。<br>3.从EFI分区(不一定第一个扇区)找到、读入、执行启动管理器（\efi\Microsoft\boot\bootmgfw.efi）。<br>4.bootmgfw.efi导入EFI分区BCD文件（efi\Microsoft\BCD），然后根据其配置内容载入程序winload.efi（位置：C:\Windows\system32\winload.efi）来加载OS内核。<br>Tips：BCD是一个数据库文件，如果包含多个系统，信息会包含在BCD中，通过显示一个系统列表供用户选择。</p><h2 id="Windows用户管理"><a href="#Windows用户管理" class="headerlink" title="Windows用户管理"></a>Windows用户管理</h2><p>每个账户有自己唯一的SID（安全标识符）<br>账户组作用：简化权限赋予</p><h3 id="常见内置组"><a href="#常见内置组" class="headerlink" title="常见内置组"></a>常见内置组</h3><p>1）Administrators：管理员组<br>2）Backup Operators：具有备份和还原的权限组<br>3）Guests：来宾组<br>4）Network ：网络配置组<br>5）Remote：远程桌面组<br>6）Users：新用户的默认组<br>7）Print ：打印机组</p><h3 id="特殊本地内置组"><a href="#特殊本地内置组" class="headerlink" title="特殊本地内置组"></a>特殊本地内置组</h3><p>9）Everyone：任何一个用户都属于这个组<br>10）Authenticated Users：任何使用有效用户来登录此计算机的用户，都属于此组<br>11）Interactive:任何在本地登录（按ctrl+alt+del键登录）的用户，都属于此组<br>12）Network:任何通过网络来登录此计算机的用户，都属于此组</p><h3 id="组管理命令"><a href="#组管理命令" class="headerlink" title="组管理命令"></a>组管理命令</h3><p>1.net localgroup #show group table<br>2.net localgroup groupname #show group user<br>3.net localgroup groupname /add #add group<br>4.net localgroup groupname /del #del group<br>5.net localgroup groupname username /del # 从组中踢出用户<br>6.net localgroup groupname username /add # 添加用户到组</p><h3 id="内置账户"><a href="#内置账户" class="headerlink" title="内置账户"></a>内置账户</h3><p>1.administrator #管理员<br>2.system #系统账户，最高权限<br>3.local services #本地服务账户，user的权限<br>4.network services #网络服务账户 user权限<br>Tips：内置账号无法删除</p><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><p>1.net user #show user table<br>2.net user username password #change password<br>3.net user username password /add #add user<br>4.net user username /del #delete user</p><h2 id="Windows文件系统"><a href="#Windows文件系统" class="headerlink" title="Windows文件系统"></a>Windows文件系统</h2><p>文件系统是操作系统用于再存储设备组织文件的方法。<br>从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。<br>每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190309112559820.png" alt="Windows文件系统结构"></p><h3 id="常见的文件系统"><a href="#常见的文件系统" class="headerlink" title="常见的文件系统"></a>常见的文件系统</h3><p>NTFS(最常用)<br>FAT32<br>FAT<br>ExFAT</p><p>FAT在软盘、闪存(U盘)，以及很多嵌入式设备上常见。<br>ExFAT(FAT64)，ExFAT是专门为闪存设计的文件系统，单个文件突破了4G的限制。ExFAT在windows、Linux、Mac系统上都是可以读写。</p><p>在稳定性和安全性方面，NTFS要优于FAT32，但是FAT32兼容较旧的存储设备及系统，如DOS系统等。两者的主要区别体现在：<br>1.FAT32最大只支持32G独立分区，NTFS最大支持的独立分区是2TB<br>2.FAT32不支持超过4G的单个文件<br>3.NTFS无法运行在DOS系统下，FAT32则可以兼容DOS系统</p><h2 id="Windows服务"><a href="#Windows服务" class="headerlink" title="Windows服务"></a>Windows服务</h2><p>Microsoft Windows 服务可以在 Windows 中长时间运行应用程序，非常适合需要长时间运行功能时使用。</p><h2 id="Windows注册表"><a href="#Windows注册表" class="headerlink" title="Windows注册表"></a>Windows注册表</h2><p>注册表是Microsoft Windows中的一个重要的数据库，用于存储系统和应用程序的设置信息，在运行中输入regedit即可进入。</p><p><img src="https://img-blog.csdnimg.cn/20190327075949591.png" alt="Windows注册表结构"></p><h3 id="注册表包括5个根键"><a href="#注册表包括5个根键" class="headerlink" title="注册表包括5个根键"></a>注册表包括5个根键</h3><p>1.HKEY_CLASSES_ROOT<br>说明：启动应用程序所需的全部信息。<br>2.HKEY_CURRENT_USER<br>说明：当前登录用户的配置信息。<br>3.HKEY_LOCAL_MACHINE<br>说明：本地计算机的系统信息，包括硬件和操作系统信息，安全数据和各类软件设置信息。<br>4.HKEY_USERS<br>说明：所有用户的配置数据，这些数据只有在用户登录系统时才能访问。<br>5.HKEY_CURRENT_CONFIG<br>说明：硬件的配置信息，从HKEY_LOCAL_MACHINE中映射出来。</p><h3 id="注册表基本数据类型"><a href="#注册表基本数据类型" class="headerlink" title="注册表基本数据类型"></a>注册表基本数据类型</h3><p>二进制值（reg_binary）:多数硬件信息以二进制数据存储，以十六进制格式显示在注册表编辑器中<br>字符串值（reg_sz）:包括字符串的注册表键，使用字符串数据类型<br>双字节值（reg_dword）:是32位信息常显示成4个字节。它在出错控制功能上用处极大，其数据一般以十六进制格式显示在注册<br>表编辑器中。<br>多字符串值(reg_multi_sz):将一系列项目作为单独的一个值。对于多种网络协议、多个项目、设备列表以及其他类似<br>的列表项目来说，可以使用多字符串值<br>可扩充字符串值（reg_expand_sz）：代表一个可扩展的字符串</p><h2 id="Windows进程"><a href="#Windows进程" class="headerlink" title="Windows进程"></a>Windows进程</h2><p>进程本质上是操作系统正在执行的一个程序</p><img src="/.io//迅雷下载\szszzszs13.github.io(1)\source\_posts\操作系统基础\1.jpg" alt="Lena" style="zoom:50%;"><h3 id="常用进程管理命令"><a href="#常用进程管理命令" class="headerlink" title="常用进程管理命令"></a>常用进程管理命令</h3><p>1.netstat -ano | findstr 指定端口号 #查看指定端口的进程<br>2.taskkill /im cmd.exe #结束某进程<br>3.taskkill /pid pidnumber #结束pid为pidnumber的进程</p><h2 id="Windows设备管理"><a href="#Windows设备管理" class="headerlink" title="Windows设备管理"></a>Windows设备管理</h2><p>设备管理为了克服设备与cpu速度不匹配问题，使主机和设备并行工作</p><h2 id="Windows日志文件"><a href="#Windows日志文件" class="headerlink" title="Windows日志文件"></a>Windows日志文件</h2><p>Windows日志文件记录着Windows系统中所发生的一切<br>位置C:/windows/System32/winevt/Logs，运维人员建议修改日志默认位置<br>Windows日志：System.evtx<br>运行输入eventvwr进入事件查看器</p><p>入侵日志分析：利用Log Parser将日志文件导出为xlsx表格，分析攻击者的操作</p><h1 id="MAC-OS基础"><a href="#MAC-OS基础" class="headerlink" title="MAC OS基础"></a>MAC OS基础</h1><h2 id="日志与日志文件"><a href="#日志与日志文件" class="headerlink" title="日志与日志文件"></a>日志与日志文件</h2><p>系统日志文件 /var/log/system.log<br>cat -n app.log | grep “error”：查询日志中含有某个关键字error的信息，显示行号。</p><h2 id="MAC文件系统"><a href="#MAC文件系统" class="headerlink" title="MAC文件系统"></a>MAC文件系统</h2><p><img src="https://img.linux.net.cn/data/attachment/album/201807/02/094428ko2tc8saplc2apto.png" alt="标准 Unix 文件系统"></p><p>​                                                                                                     </p><h3 id="Mac文件目录"><a href="#Mac文件目录" class="headerlink" title="Mac文件目录"></a>Mac文件目录</h3><p>Linux有的文件Mac也有，但是是隐藏文件。</p><p>Mac特有目录：</p><ul><li>/Applications 应用程序默认安装路径</li><li>/Library 系统文件</li><li>/Network 网络节点存放</li><li>/System 只包含一个Library目录，存放了系统的绝大部分组件</li><li>/Users 存放用户的数据</li><li>/Volumes 存放挂载点</li><li>/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。</li><li>/private 存放了/tmp, /var, /etc等链接目录的目标目录。</li></ul><h3 id="Mac文件系统格式"><a href="#Mac文件系统格式" class="headerlink" title="Mac文件系统格式"></a>Mac文件系统格式</h3><p>HFS+、 APFS（最新的）</p><h2 id="Mac用户管理命令"><a href="#Mac用户管理命令" class="headerlink" title="Mac用户管理命令"></a>Mac用户管理命令</h2><p>dscl . -list /Users UniqueID（用户id）#查看用户<br>dscl . -list /Groups  PrimaryGroupID #查看用户组<br>dscl . -create /Users/sz UniqueID 888 #新建sz用户，id为888<br>dscl . -passwd /Users/sz 1234 #修改密码<br>dscl . -delete /Users/sz #删除用户<br>dscl . -create /Groups/mygroup #新建组<br>dscl . -append /Groups/mygroup groupMembership sz #把sz添加到组<br>dscl . -list /groups GroupMembership #查看所有组下的用户</p><h1 id="移动智能设备操作系统"><a href="#移动智能设备操作系统" class="headerlink" title="移动智能设备操作系统"></a>移动智能设备操作系统</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>Android是基于Linux（不包含<a href="https://baike.baidu.com/item/GNU/671972">GNU</a>组件）的自由及开放源代码的操作系统</p><h3 id="Android日志与日志文件"><a href="#Android日志与日志文件" class="headerlink" title="Android日志与日志文件"></a>Android日志与日志文件</h3><p>Android有四类日志文件，分别是：main, system, radio和events。</p><p>main：应用程序日志<br>system：系统日志<br>radio：无线设备日志<br>events：诊断系统问题日志</p><h4 id="Logger日志格式"><a href="#Logger日志格式" class="headerlink" title="Logger日志格式"></a>Logger日志格式</h4><p>main、system和radio三种类型的日志格式是相同的。日志格式如下所示：</p><p><img src="https://pic1.zhimg.com/v2-a2f876631161fca1f52d5ae9910a18dc_b.jpg" alt="日志格式"></p><p>Priority：是一个整数，代表的是日志的优先级；<br>日志的优先级按重要程度不同划分为：VERBOSE、DEBUG、INFO、WARN、ERROR和FATAL六种。<br>tag：是一个字符串，代表的是日志的标签；<br>message：是一个字符串，代表的是日志的内容。</p><p>events类型日志没有优先级标签</p><h4 id="日志分析方法"><a href="#日志分析方法" class="headerlink" title="日志分析方法"></a>日志分析方法</h4><p>使用Logcat对Android系统log进行分析</p><h3 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h3><p>adb:Android 调试桥</p><p>adb shell  #进入Linuxshell模式<br>adb shell command #单条Linux命令<br>adb root #获取管理员权限<br>adb pull &lt;远程路径&gt; &lt;本地路径&gt; #从设备上下载文件到电脑<br>adb shell netcfg/ifconfig #show ip</p><h2 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h2><p>iOS属于类Unix的操作系统</p><h3 id="IOS日志与日志文件"><a href="#IOS日志与日志文件" class="headerlink" title="IOS日志与日志文件"></a>IOS日志与日志文件</h3><img src="https://images2015.cnblogs.com/blog/791499/201609/791499-20160922115017449-130119239.png" alt="IOS日志与日志文件"><p>2.1进程信息<br>第一部分是闪退进程的相关信息：<br>Incident Identifier ： 是崩溃报告的唯一标识符<br>CrashReporter Key： 是与设备标识相对应的唯一键值。根据大量机子的出现频率可以判断是否是一个普遍的问题<br>Hardware Model ：标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明只在某特定类型的设备上有问题<br>Process：操作权限<br>Path:崩溃文件的路径<br>Identifier:项目标识符<br>Version:版本号</p><p>2.2基本信息<br>这部分包括闪退发生的日期Date/Time和时间Launch Time，设备的iOS版本OS Version</p><p>2.3、异常信息<br>Exception Type:异常的类型<br>Exception Codes ：异常错误码<br>Termination Reason：闪退的原因<br>Triggered by Thread：出现问题在哪个线程，首先确定在哪个线程中出了问题，然后再去定位。</p><h3 id="基本操作命令-1"><a href="#基本操作命令-1" class="headerlink" title="基本操作命令"></a>基本操作命令</h3><p>Korn Shell(Unix Shell)</p><p>w #显示当前系统活动的总信息<br>df /tmp #显示文件系统的总空间和可用空间<br>uname -a #显示系统全部信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Weclome</title>
      <link href="2021/05/29/Welcome/"/>
      <url>2021/05/29/Welcome/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
